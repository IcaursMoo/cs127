\documentclass{article}
% generated by Madoko, version 1.0.0-rc5
%mdk-data-line={1}


\usepackage[heading-base={2},section-num={False},bib-label={True}]{madoko2}


\begin{document}



%mdk-data-line={2}
\newcommand{\zo}{\{0,1\}}
\newcommand{\getsr}{\leftarrow_{\text{\tiny R}}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\N}{\mathbb{N}}
%mdk-data-line={8}
\noindent\mdline{8}\emph{CS 127: Cryptography / Boaz Barak}\mdline{8}%mdk

%mdk-data-line={11}
\section{\mdline{11}1.\hspace*{0.5em}\mdline{11}Homework 2}\label{sec-homework-2}%mdk%mdk

%mdk-data-line={13}
\noindent\mdline{13}Total of 128 points.%mdk

%mdk-data-line={16}
\subsection{\mdline{16}1.1.\hspace*{0.5em}\mdline{16}Exercises from Lecture 3}\label{sec-exercises-from-lecture-3}%mdk%mdk

%mdk-data-line={18}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={18}
\item\mdline{18}(impossibility of statistically testing randomness, 15 points) Let \mdline{18}$T_1,\ldots,T_M:\zo^n\rightarrow\zo$\mdline{18} be a collection of function that are supposed to be statistical tests for randomness. Prove that if \mdline{18}$n$\mdline{18} is large enough and  \mdline{18}$M<2^{100n}$\mdline{18} there exists a distribution \mdline{18}$X$\mdline{18} that passes all these tests but is very far from the uniform distribution. Concretely, show that
there exists a random variable \mdline{19}$X$\mdline{19} over \mdline{19}$\zo^n$\mdline{19} such that:

%mdk-data-line={20}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={20}
\item\mdline{20}For every \mdline{20}$i\in [M]$\mdline{20}, \mdline{20}$| \E[ T_i(X)]-\E[T_i(U_n)]|<0.001$\mdline{20} where \mdline{20}$U_n$\mdline{20} is the uniform distribution over \mdline{20}$n$\mdline{20} bits.%mdk

%mdk-data-line={21}
\item\mdline{21}But, there exists some \mdline{21}$T^*:\zo^n\rightarrow\zo$\mdline{21} such that \mdline{21}$| \E[ T^*(X)] - \E[T^*(U_n)] |>0.999$\mdline{21}.

%mdk-data-line={22}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={23}
\noindent\mdline{23}\textbf{Proof}.  \mdline{23}Take \mdline{23}$S \subset \zo^n$\mdline{23} such that \mdline{23}$|S| < 2^{n + \log \epsilon}$\mdline{23}
for some small \mdline{24}$\epsilon \in (0,1]$\mdline{24}. Let \mdline{24}$X$\mdline{24} be any distribution with support \mdline{24}$S$\mdline{24} (ie, \mdline{24}$P[X = x] > 0$\mdline{24} for \mdline{24}$s \in S$\mdline{24}
and \mdline{25}$\Pr[X = x] = 0$\mdline{25} for \mdline{25}$x \notin S$\mdline{25}). Then consider the test \mdline{25}$T^*: \zo^n \to \zo$\mdline{25} defined as the characteristic
or indicator function of the set \mdline{26}$S$\mdline{26}:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={29}
T^*(x) = \begin{cases} 
 1 & x \in S \\
 0 & x \notin S 
\end{cases}
\]%mdk
\mdline{34}Then note that this test distinguishes between \mdline{34}$U_n$\mdline{34} and \mdline{34}$X$\mdline{34}. 
\noindent\noindent\[%mdk-data-line={36}
\begin{aligned}
|\E[ T^*(X)] - \E[T^*(U_n)| &= \left|\sum_{x \in S} T^*(x) - \frac{1}{2^n} \sum_{x\in \zo^n} T^*(x) \right| \\
&= |1 - \frac{|S|}{2^n}| \\
&= 1 - \frac{|S|}{2^n} \\
&> 1 - 2^{\log \epsilon} \\
&= 1 - \epsilon
\end{aligned}
\]%mdk
\mdline{44}The first expectation is simplified because it\mdline{44}'\mdline{44}s simply the sum of the probabilities of the distribution
\mdline{45}$X$\mdline{45} over it\mdline{45}'\mdline{45}s support (which is \mdline{45}$1$\mdline{45}) and the second expectation is simply the proportion of \mdline{45}$|S|$\mdline{45} to \mdline{45}$\zo^n$\mdline{45}.
Note that we can make epsilon arbitrarily small, and in particular, we can take \mdline{46}$\epsilon = 0.001$\mdline{46}. Now
let \mdline{47}$X$\mdline{47} be the uniform distribution over \mdline{47}$S$\mdline{47}, the restricted sample space. Then consider, for fixed \mdline{47}$i$\mdline{47}, 
the probability of \mdline{48}$\E[T_i(X)]$\mdline{48} deviating from the \mdline{48}$\mu = \E[T_i(U_n)]$\mdline{48} by more than \mdline{48}$\epsilon$\mdline{48}. 
\noindent\noindent\[%mdk-data-line={50}
\begin{aligned}
\Pr[|\E[T_i(X)] - \E[T_i(U_n)]|  > \epsilon ] &= \Pr \left[ |\sum_{x \in S} \frac{T_i(x)}{|S|}  - \mu | > \epsilon \right]  \\
&< 2^{\frac{-\epsilon^2 n}{4}}
\end{aligned}
\]%mdk
\mdline{55}The above inequality follows immediately from the Chernoff bound. Note that \mdline{55}$\E[T_i(X)]$\mdline{55} is essentially
a sample mean of \mdline{56}$T_i(U_n)$\mdline{56} (we\mdline{56}'\mdline{56}re restricted \mdline{56}$S \subset \zo^n$\mdline{56}). With the above, we now have a tight
upper bound on the probability that the test \mdline{57}\emph{does}\mdline{57} distinguish between \mdline{57}$X$\mdline{57} and \mdline{57}$U_n$\mdline{57}. Then simply note
that the probability that none of the tests distinguish is the complement of at least one of the tests
distingushing. Letting \mdline{59}$D_i$\mdline{59} be the event where \mdline{59}$T_i$\mdline{59} successfully distinguishes between \mdline{59}$X$\mdline{59} and \mdline{59}$U_n$\mdline{59}
by some \mdline{60}$\epsilon$\mdline{60}, the probability of successfully distinguishing, \mdline{60}$D$\mdline{60} is given by:
\noindent\noindent\[%mdk-data-line={62}
\begin{aligned}
\Pr[D] &= \Pr[ \bigcup_i D_i ] \\
&\leq \sum_{i} \Pr[D_i] \\
&< \sum_{i} 2^{\frac{-\epsilon^2 n}{4}} \\
&= \frac{M}{2^{\frac{\epsilon^2 n}{4}}} 
\end{aligned}
\]%mdk
\mdline{69}The first inequality is simply using the union-bound, and the second uses the Chernoff bound shown
previously. From the above we can immediately see that for any given \mdline{70}$\epsilon > 0$\mdline{70}, we can find
a large enough \mdline{71}$n$\mdline{71} so that the probability of any of the tests \mdline{71}$T_i$\mdline{71} successfully distinguishing 
the two distributions \mdline{72}$X$\mdline{72} and \mdline{72}$S$\mdline{72} can be made arbitrarily small. This shows that for large enough \mdline{72}$n$\mdline{72}
and for fixed \mdline{73}$M$\mdline{73}, then no test will successfully distinguish between \mdline{73}$X$\mdline{73} and \mdline{73}$U_n$\mdline{73}. However, we showed
before that the indicator test \mdline{74}$T^*$\mdline{74} will always successfully distinguish between \mdline{74}$U_n$\mdline{74} and any distribution
\mdline{75}$X$\mdline{75} with support \mdline{75}$S \subset \zo ^n$\mdline{75}. 
\mdline{76}\mdfloatright{\ensuremath{\Box}}\mdline{76}%mdk
%mdk
\end{itemize}%mdk%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={78}
\noindent\mdline{78}(No points, just food for thought.) Based on this exercise, what do you believe can we say about a distribution \mdline{78}$X$\mdline{78} if it passes the FIPS 140-2 testing suite for randomness?
Based on the above, we can\mdline{79}'\mdline{79}t say much. Testing for randomness appears to be impossible.%mdk

%mdk-data-line={81}
\begin{enumerate}[,start=2]%mdk

%mdk-data-line={81}
\item{}
%mdk-data-line={81}
\mdline{81}(20 points) We call a sequence \mdline{81}$\{ X_n \}_{n\in\N}$\mdline{81} where \mdline{81}$X_n$\mdline{81} is a distribution over \mdline{81}$\zo^n$\mdline{81}  \mdline{81}\textbackslash{}\mdline{81}emph\{pseudorandom\} if it\mdline{81}'\mdline{81}s computationally indistinguishable from the sequence \mdline{81}$\{ U_n \}$\mdline{81} where \mdline{81}$U_n$\mdline{81} is the uniform distribution over \mdline{81}$\zo^n$\mdline{81}. Are the following sequences pseudorandom? prove or refute.%mdk

%mdk-data-line={82}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,label=\alph*.]%mdk

%mdk-data-line={82}
\item\mdline{82}(10 points) \mdline{82}$\{ X_n \}$\mdline{82} where  \mdline{82}$X_n$\mdline{82} be the following distribution: we pick \mdline{82}$x_1,\ldots,x_{n-1}$\mdline{82}
uniformly at random in \mdline{83}$\zo^{n-1}$\mdline{83}, and let \mdline{83}$x_n$\mdline{83} be the parity (i.e. XOR) of
\mdline{84}$x_1,\ldots,x_{n-1}$\mdline{84}, we output \mdline{84}$x_1,\ldots, x_n$\mdline{84}.

%mdk-data-line={85}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={86}
\noindent\mdline{86}\textbf{Proof}.  \mdline{86}The sequence \mdline{86}$\{X_n\}$\mdline{86} is computationally distinguishable from \mdline{86}$\{U_n\}$\mdline{86}. Note that this follows from 
the fact that for any well-defined \mdline{87}$n$\mdline{87}, \mdline{87}$X_n$\mdline{87} is computationally distinguishable from \mdline{87}$U_n$\mdline{87}. A successful distinguisher
can be defined as \mdline{88}$D$\mdline{88}, where on input \mdline{88}$s \in \zo^n$\mdline{88}, \mdline{88}$D$\mdline{88} will take the parity of the first \mdline{88}$n-1$\mdline{88} bits
and output \mdline{89}$1$\mdline{89} if \mdline{89}$s_n = \oplus_{i=1}^{n-1}x_i$\mdline{89} and \mdline{89}$0$\mdline{89} otherwise. Then note:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={92}
|\E[D(X_n)] - \E[D(U_n]| = |1 - \frac{1}{2}| = \frac{1}{2}
\]%mdk
\mdline{94}Note that the first expectation is \mdline{94}$1$\mdline{94} because it holds for all strings drawn from \mdline{94}$X_n$\mdline{94} while the
second expected value only holds half of the time for strings drawn from \mdline{95}$U_n$\mdline{95}. Furthermore, note that
\mdline{96}$D$\mdline{96} is linear in the input, and therefore is computationally efficient. 
\mdline{97}\mdfloatright{\ensuremath{\Box}}\mdline{97}%mdk

%mdk-data-line={98}
\item\mdline{98}(10 points) \mdline{98}$\{Z_n \}$\mdline{98} where for \mdline{98}$n$\mdline{98} large enough, with probability \mdline{98}$2^{-n/10}$\mdline{98} we output an \mdline{98}$n$\mdline{98} bit  string encoding the text \mdline{98}\textbackslash{}\mdline{98}texttt\{\mdline{98}\textquoteleft{}'This is not a pseudorandom distribution\textquoteright{}\mdline{98}'\mdline{98}\} (say encode
in ASCII and pad with zeros), and with probability \mdline{99}$1-2^{-n/10}$\mdline{99} pick a random string. For
\mdline{100}$n$\mdline{100} that is not large enough to encode the text, \mdline{100}$Z_n$\mdline{100} always outputs the all zeroes
string.

%mdk-data-line={102}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={103}
\noindent\mdline{103}\textbf{Proof}.  \mdline{103}We proof that the sequence \mdline{103}$\{Z_n\}$\mdline{103} is computationally distinguishable from \mdline{103}$\{U_n\}$\mdline{103}. We do this by
showing that for large enough \mdline{104}$n$\mdline{104} and a computationally efficient distinguisher \mdline{104}$D$\mdline{104}, 
\mdline{105}$|\E[D(Z_n)] - \E[D(Z_n)]|$\mdline{105} is non-negligible. The construction of this distinguisher is very 
straight forward. Let \mdline{106}$t$\mdline{106} be the number of bits required to encode the given phrase in 
ASCII (note that this is fixed). On input \mdline{107}$s \in \zo^n$\mdline{107} for \mdline{107}$n \geq t$\mdline{107}, \mdline{107}$D$\mdline{107} looks at the first \mdline{107}$t$\mdline{107} bits of the input
string \mdline{108}$s$\mdline{108}. If the first \mdline{108}$t$\mdline{108} bits are equal to the phrase, \mdline{108}$D(s) = 1$\mdline{108}, otherwise \mdline{108}$D(s) = 0$\mdline{108}. 
Then note the following for \mdline{109}$n \geq t$\mdline{109}:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={112}
\begin{aligned}
| \E[D(Z_n)] - \E[D(U_n)] | &= | 1 - \frac{2^{n-t}}{2^n} | \\
&= \frac{1}{2^t}
\end{aligned}
\]%mdk
\mdline{117}The first expectation is simplified because the property holds for all \mdline{117}$s \in_R Z_n$\mdline{117}, 
and the second expectation is just using the naive definition of probability to count 
the number of \mdline{119}$s \in_R U_n$\mdline{119} such that the first \mdline{119}$t$\mdline{119} bits are fixed to the given ASCII encoding.
Then note that \mdline{120}$2^{-t}$\mdline{120} is fixed and non-negligible, therefore the two distributions are
distinguishable. Furthermore, note that the running time of the algorithm is actually constant,
depending only on \mdline{122}$t$\mdline{122}, and is therefore computationally efficient. 
\mdline{123}\mdfloatright{\ensuremath{\Box}}\mdline{123}%mdk
%mdk
\end{enumerate}%mdk%mdk

%mdk-data-line={125}
\item{}
%mdk-data-line={125}
\mdline{125}(24 points) Suppose that \mdline{125}$G:\zo^n\rightarrow\zo^{3n}$\mdline{125} is a secure pseudorandom generator. For each one of the constructions \mdline{125}$G^1,G^2,G^3$\mdline{125} below either prove that they are necessarily a secure pseudorandom generator or give a counterexample (which is a construction, based on the Cipher, PRG or PRG conjectures, of a generator \mdline{125}$G$\mdline{125} such that \mdline{125}$G_i$\mdline{125} would not be secure.)%mdk

%mdk-data-line={126}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,label=\alph*.]%mdk

%mdk-data-line={126}
\item\mdline{126}(8 points) \mdline{126}$G^1(s)=G(s)_{1,\ldots,2n}$\mdline{126} (i.e., the first \mdline{126}$2n$\mdline{126} bits of \mdline{126}$G(s)$\mdline{126}).

%mdk-data-line={127}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={128}
\noindent\mdline{128}\textbf{Proof}.  \mdline{128}$G^1$\mdline{128} is secure. Suppose this is not the case. Then there exists a distinguisher 
\mdline{129}$D: \zo^{2n} \to \zo$\mdline{129} which can distinguish
between \mdline{130}$G^1(U_n)$\mdline{130} and \mdline{130}$U_{2n}$\mdline{130}. Formally, \mdline{130}$\exists D$\mdline{130} computationally efficient such that%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={133}
|\E[D(G^1(U_n))] - \E[D(U_{2n})]| > \epsilon(n)
\]%mdk
\mdline{135}for non-negligible \mdline{135}$\epsilon(n)$\mdline{135}.
Then note that we can construct a distinguisher \mdline{136}$D': \zo^{3n} \to \zo$\mdline{136}
that can distinguish between \mdline{137}$G(U_n)$\mdline{137} and \mdline{137}$U_{3n}$\mdline{137}, contradicting our assumption that \mdline{137}$G$\mdline{137} is secure.
Let \mdline{138}$D'$\mdline{138} be the function which on input \mdline{138}$s \in \zo^{3n}$\mdline{138} discards the final \mdline{138}$n$\mdline{138} bits and feeds
the remaining string to \mdline{139}$D$\mdline{139}, outputing the results of \mdline{139}$D$\mdline{139}. Then note that,
\noindent\noindent\[%mdk-data-line={141}
\begin{aligned}
D'(G(U_n)) &= D(G(U_n)_{1,\cdots,2n}) = D(G^1(U_n)) \\
D'(U_{3n}) &= D(U_{2n})   
\end{aligned}
\]%mdk
\mdline{146}The second equality follows almost immediately, and the first is from the fact that we retain only
the first \mdline{147}$2n$\mdline{147} bits, which is the same process that \mdline{147}$G^1$\mdline{147} performs. With the above, we have:
\noindent\noindent\[%mdk-data-line={149}
|\E[D'(G(U_n))] - \E[D'(U_{3n})]| = | \E[D(G^1(U_n)] - \E[D(U_{2n})] | > \epsilon(n) 
\]%mdk
\mdline{151}a contradiction on the security of \mdline{151}$G$\mdline{151}. Therefore, \mdline{151}$G^1$\mdline{151} must be secure.
\mdline{152}\mdfloatright{\ensuremath{\Box}}\mdline{152}%mdk

%mdk-data-line={153}
\item\mdline{153}(8 points) \mdline{153}$G^2(s)=G(0,s_2,\ldots,s_n)$\mdline{153} (i.e., the output of \mdline{153}$G(s)$\mdline{153} but setting the first seed bit to zero)

%mdk-data-line={154}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={155}
\noindent\mdline{155}\textbf{Proof}.  \mdline{155}$G^2$\mdline{155} is not secure. Consider \mdline{155}$G: \zo^n \to \zo^{3n}$\mdline{155} which is constructed as follows. By the PRG 
conjecture (combined with the length extension theorem), there exists a secure \mdline{156}$G': \zo^n \to \zo^{3n - 1}$\mdline{156}.
Then on input \mdline{157}$s \in \zo^n$\mdline{157}, \mdline{157}$G$\mdline{157} feeds \mdline{157}$s$\mdline{157} to \mdline{157}$G'$\mdline{157} producing a \mdline{157}$y \in \zo^{3n-1}$\mdline{157} which is pseudorandom. Then
it simply appends \mdline{158}$s_1$\mdline{158} to \mdline{158}$y$\mdline{158} and gives as output \mdline{158}$y \circ s_1$\mdline{158}. Note that if \mdline{158}$y$\mdline{158} is pseudorandom, 
then because \mdline{159}$s_1$\mdline{159} is uniformly distributed, \mdline{159}$y \circ s_1$\mdline{159} is also pseudorandom. However, this 
leads to a \mdline{160}$G^2$\mdline{160} which is not pseudorandom. Given the above construction, we can easily construct
a distinguisher \mdline{161}$D$\mdline{161} which on input \mdline{161}$s \in \zo^{3n}$\mdline{161} checks the last bit of \mdline{161}$s$\mdline{161}. If \mdline{161}$s_{3n}$\mdline{161} is \mdline{161}$0$\mdline{161}, 
then it outputs \mdline{162}$1$\mdline{162}, otherwise it outputs \mdline{162}$0$\mdline{162}. Then we have:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={165}
|\E[D(G^2(U_n))] - \E[D(U_{3n})] | = |1 - \frac{1}{2}| = \frac{1}{2}
\]%mdk
\mdline{167}which is non-negligible, with \mdline{167}$D$\mdline{167} computationally efficient, and therefore \mdline{167}$G^2$\mdline{167} is insecure despite
the fact that \mdline{168}$G$\mdline{168} is secure.
\mdline{169}\mdfloatright{\ensuremath{\Box}}\mdline{169}%mdk

%mdk-data-line={170}
\item\mdline{170}(8 points) \mdline{170}$G^3(s_1,\ldots,s_n)=G(s_n,\ldots,s_1)$\mdline{170} (i.e., the output of \mdline{170}$G(s')$\mdline{170} where \mdline{170}$s'$\mdline{170} is obtained by reversing \mdline{170}$s$\mdline{170}).

%mdk-data-line={171}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={172}
\noindent\mdline{172}\textbf{Proof}.  \mdline{172}$G^3$\mdline{172} is secure. Suppose not. Then there exists a computationally efficient distinguisher \mdline{172}$D: \zo^{n} \to \zo$\mdline{172}
between \mdline{173}$G^3(U_n)$\mdline{173} and \mdline{173}$U_{3n}$\mdline{173}. However, note that this same distinguisher can distinguish between
\mdline{174}$G(U_n)$\mdline{174} and \mdline{174}$U_{3n}$\mdline{174}. The reason for this is that if the inputs \mdline{174}$s$\mdline{174} are distributed uniformly, than
the reverse inputs are also distributed uniformly. Therefore \mdline{175}$G^3(U_n)$\mdline{175} has the same distribution as
\mdline{176}$G(U_n)$\mdline{176}, which implies that%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={179}
|\E[D(G(U_n))] - \E[D(U_{3n})| = |\E[D(G^3(U_n))] - \E[D(U_{3n})]| > \epsilon(n)  
\]%mdk
\mdline{181}for some non-negligible \mdline{181}$\epsilon(n)$\mdline{181} where \mdline{181}$D$\mdline{181} is computationally efficient. 
\mdline{182}\mdfloatright{\ensuremath{\Box}}\mdline{182}%mdk
%mdk
\end{enumerate}%mdk%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={185}
\subsection{\mdline{185}1.2.\hspace*{0.5em}\mdline{185}Exercises from Lecture 4}\label{sec-exercises-from-lecture-4}%mdk%mdk

%mdk-data-line={187}
\begin{enumerate}[,start=4]%mdk

%mdk-data-line={187}
\item{}
%mdk-data-line={187}
\mdline{187}(24 points) In these three questions you\mdline{187}'\mdline{187}ll show that if we have
a pseudorandom function family with particular input and output sizes, we can easily obtain a
family that handles different inputs and outputs.%mdk

%mdk-data-line={191}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,label=\alph*.]%mdk

%mdk-data-line={191}
\item\mdline{191}(Padding inputs and outputs, 8 points) Suppose that \mdline{191}$\{ f_s \}$\mdline{191} is a pseudorandom function collection where for every \mdline{191}$s\in\zo^n$\mdline{191}, \mdline{191}$f_s$\mdline{191} maps   \mdline{191}$\zo^n$\mdline{191} to \mdline{191}$\zo^n$\mdline{191}. Prove that if we define \mdline{191}$f'_s$\mdline{191} to be function that on input \mdline{191}$i\in [2^{n/2}]$\mdline{191} outputs the first bit of \mdline{191}$f_s(2^{n/2}+i)$\mdline{191} then \mdline{191}$\{ f'_s \}$\mdline{191} is a pseudorandom function collection (with one bit output).

%mdk-data-line={192}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={193}
\noindent\mdline{193}\textbf{Proof}.  \mdline{193}Suppose \mdline{193}$\{f_s\}$\mdline{193} is a pseudorandom function collection but \mdline{193}$\{f_s'\}$\mdline{193} is not. Then there exists a 
computationally efficient adversary \mdline{194}$A'$\mdline{194} with access to a black box \mdline{194}$B_s'(\cdot): [2^{n/2}] \to \{0,1\}$\mdline{194}
which can distinguish with non-negligible probability \mdline{195}$\epsilon(n/2)$\mdline{195} between \mdline{195}$B_s'(\cdot) = f'_s(\cdot)$\mdline{195}
and \mdline{196}$B_s'(\cdot) = H'(\cdot)$\mdline{196} where \mdline{196}$H' \gets [2^{n/2}] \to \zo$\mdline{196} (so \mdline{196}$A'$\mdline{196} can tell whether 
we\mdline{197}\textquoteleft{}re using a completely random function or a pseudorandom function from our collection $\{f_s^{\prime}\}$). 
Then note that we can construct an 
adversary $A$ with access to a black box $B_s(\cdot): [2^n] \to [2^n]$ which can distinguish between
$B_s(\cdot) = f_s(\cdot)$ or $B_s(\cdot) = H(\cdot)$ for $H \gets [2^n] \to [2^n]$. We do this as
follows, by allowing $A$ access to $A$\textquoteright{}\mdline{201}. When \mdline{201}$A$\mdline{201}'\mdline{201} queries \mdline{201}$B_s'(\cdot)$\mdline{201} with some value 
\mdline{202}$i \in [2^{n/2}]$\mdline{202}, \mdline{202}$A$\mdline{202} forwards the value \mdline{202}$2^{n/2} + i$\mdline{202} to \mdline{202}$B_s(\cdot)$\mdline{202}, which then returns a 
string \mdline{203}$s \in \zo^n$\mdline{203}. A the proceeds to forward the value \mdline{203}$s_1$\mdline{203} (the first bit) to \mdline{203}$A'$\mdline{203}. After
\mdline{204}$A'$\mdline{204} is finished testing this simulated black-box, \mdline{204}$A$\mdline{204} will return whatever \mdline{204}$A'$\mdline{204} returns. 
Then note that if the \mdline{205}$B_s(\cdot)$\mdline{205} is completely random, the bits fed to \mdline{205}$A'$\mdline{205} will be completely
random. Similarly, if \mdline{206}$B_s(\cdot)$\mdline{206} is \mdline{206}$f_s(\cdot)$\mdline{206}, then the bits fed to \mdline{206}$A'$\mdline{206} will have the
same distribution as \mdline{207}$f'_s(\cdot)$\mdline{207}.%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={210}
\begin{aligned}
&|\E_{s\in\zo^n}[A^{F(s,\cdot)}(1^n)] - \E_{H \gets [2^n] \to [2^n]}[A^{H}(1^n)]|\\
&= |\E_{s \in \zo^n}[A'^{F'(s,\cdot)}(1^n)] - \E_{H' \gets [2^{n/2}] \to \zo}[A'^{H}(1^n)]| \\
&> \epsilon(n/2)
\end{aligned}
\]%mdk
\mdline{216}The above simple expresses the fact that if \mdline{216}$B_s(\cdot)$\mdline{216} is from the collection \mdline{216}$\{f_s\}$\mdline{216}, then 
\mdline{217}$A$\mdline{217} will be able to distinguish that scenario from a completely random function with the same
non-negligible probability \mdline{218}$\epsilon(n/2)$\mdline{218} with which \mdline{218}$A'$\mdline{218} can distinguish \mdline{218}$\{f_s^{\prime}\}$\mdline{218} from 
a random function. This is a contradiction on \mdline{219}$\{f_s\}$\mdline{219} being a pseudorandom function collection,
however, and therefore it must be the case that \mdline{220}$\{f'_s\}$\mdline{220} is a pseudorandom function collection.
\mdline{221}\mdfloatright{\ensuremath{\Box}}\mdline{221}%mdk

%mdk-data-line={222}
\item\mdline{222}(Increasing output size, 8 points) Prove that if there exists a collection \mdline{222}$\{ f_s \}$\mdline{222} where \mdline{222}$f_s:\zo^{|s|}\rightarrow \zo$\mdline{222} (i.e., one bit output), then then there exists a collection \mdline{222}$\{ f'_s \}$\mdline{222} with  \mdline{222}$f'_s:\zo^{|s|}\rightarrow\zo^{|s|}$\mdline{222}. See footnote for hint.\mdline{222}\mdfootnote{1}{%mdk-data-line={260}
%mdk-data-line={260}
\noindent\mdline{260}First come up with a pseudorandom family with output longer than \mdline{260}$1$\mdline{260} but shorter than \mdline{260}$|s|$\mdline{260}. For example, if \mdline{260}$s \in \zo^{n^2}$\mdline{260} then the output can be \mdline{260}$n$\mdline{260}. Then show that existence of PRF implies existence of pseudorandom generators and use that to expand your output.%mdk
\label{fn-hint-prf-expand}%mdk%mdk
}\mdline{222}

%mdk-data-line={223}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={224}
\noindent\mdline{224}\textbf{Proof}.  \mdline{224}We follow a construction which mimicks the PRF-login protocol presented in lecture
and that uses the ideas from part (a) above. Note that given our collection of functions 
\mdline{226}$\{f_s \}$\mdline{226} which maps from \mdline{226}$[2^{|S|}] \to [2^{|S|}]$\mdline{226}, we define \mdline{226}$f'_s$\mdline{226} to be the function that 
on input \mdline{227}$i \in [2^{|s|/l}]$\mdline{227} for \mdline{227}$l < |s|$\mdline{227} (where \mdline{227}$l$\mdline{227} is such that \mdline{227}$\exists k \in \mathbb{N}$\mdline{227} st.
\mdline{228}$kl = |s|$\mdline{228}) outputs the the \mdline{228}$t$\mdline{228}-th bit of the result as
\mdline{229}$f_s(i + t2^{|s|/l})$\mdline{229}. Then note that by the proof shown in (a), it\mdline{229}'\mdline{229}s clear that this new
\mdline{230}$\{f'_s \}$\mdline{230} collection consists of PRFs. Then note that each \mdline{230}$f'_s: [2^{|s|/l}] \to [2^l]$\mdline{230} for
the specified \mdline{231}$l$\mdline{231}. Then note that the existence of PRFs implies the existence of PRGs, in the
sense that we can simulate a PRG that doubles its input by querying \mdline{232}$f'_s$\mdline{232} twice (the construction
is very direct). By repeating this process, we can actually create a PRG that takes an input 
of any size and expands it polynomially (this is the PRG Conjecture with Lengh Extension). Using
this fact, we can create the collection we were seeking originally. The first step consists
of using the PRFs to create a PRG \mdline{236}$G: \zo^n \to \zo^{kn}$\mdline{236} (expands by a constant factor of \mdline{236}$k$\mdline{236}).
Then we define the final collection \mdline{237}$f''_s(x) = f'_{G(s)}(x)$\mdline{237}. Therefore, note that \mdline{237}$f''_s$\mdline{237} first
expands its seed using the PRG G, which by the PRG Conjecture, is a distribution 
indistinguishable from the uniform distribution \mdline{239}$G(U_{|s|}) \approx U_{k|s|}$\mdline{239}. It then uses 
the construction presented above for \mdline{240}$f'_s$\mdline{240} with \mdline{240}$l = |s|$\mdline{240} (which is now possible, since we have
\mdline{241}$|G(s)| = k|s|$\mdline{241}!). Then with this construction, we have a collection of functions \mdline{241}$f'_s: [2^{|s|}] \to [2^{|s|}]$\mdline{241}.
The fact that this construction is a PRF immediately follows from the fact that \mdline{242}$G$\mdline{242} is a valid
PRG, \mdline{243}$l = |s|$\mdline{243}, \mdline{243}$|G(s)| = k|s|$\mdline{243}, and that part (a) above is proven.
\mdline{244}\mdfloatright{\ensuremath{\Box}}%mdk%mdk
\end{mdbmarginx}%mdk%mdk

%mdk-data-line={246}
\item\mdline{246}(Changing PRFs input size, 8 points) Prove that if there exists a collection \mdline{246}$\{ f_s \}$\mdline{246} of pseudorandom functions with \mdline{246}$f_s:\zo^{|s|}\rightarrow\zo^{|s|}$\mdline{246} then there exists a collection \mdline{246}$\{ f'_s \}$\mdline{246} with \mdline{246}$f'_s:\zo^{*}\rightarrow\zo^{|s|}$\mdline{246} (i.e., \mdline{246}$f'_s$\mdline{246} for a random \mdline{246}$s\in\zo^n$\mdline{246} is indistinguishable from a random function from \mdline{246}$\zo^*$\mdline{246} to \mdline{246}$\zo^n$\mdline{246}. (If it makes your life easier, it\mdline{246}'\mdline{246}s fine to construct a collection \mdline{246}$\{ f'_s \}$\mdline{246} with a single output bit.)

%mdk-data-line={247}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={248}
\noindent\mdline{248}\textbf{Proof}.  \mdline{248}We lay out the general sketch for the proof first, for the sake of time. The general idea is 
that given an input of arbitrary size (the sketch is similar to construction 4.11 in the 
recommended textbook). On an input of the string \mdline{250}$m$\mdline{250} where \mdline{250}$m = poly(|s|)|s|$\mdline{250}, we split the
message into \mdline{251}$m_1,m_2, \cdots, m_{poly(|s|)}$\mdline{251} where each chunk we have \mdline{251}$|m_i| = |s|$\mdline{251}. Then 
we set \mdline{252}$t_0 = 0^{l(|s|)}$\mdline{252}, and for \mdline{252}$i = 1$\mdline{252} to \mdline{252}$i = |l(|s|)|$\mdline{252}, we set \mdline{252}$t_i = f_s(t_{i-1} \oplus m_i)$\mdline{253} for some random seed \mdline{253}$s$\mdline{253}. Finally, our algorithm outputs \mdline{253}$t_{poly(|s|)}$\mdline{253}.%mdk

%mdk-data-line={255}
\mdline{255}I\mdline{255}'\mdline{255}m actually not sure this is secure, and I\mdline{255}'\mdline{255}ve run out of time, so I\mdline{255}'\mdline{255}ll have to pass on it.%mdk

%mdk-data-line={257}
\mdline{257}Looking forward to the solutions, though!%mdk%mdk
\end{mdbmarginx}%mdk
\mdline{259}\mdfloatright{\ensuremath{\Box}}\mdline{259}%mdk
%mdk
\end{enumerate}%mdk%mdk

%mdk-data-line={262}
\item{}
%mdk-data-line={262}
\mdline{262}(20 points) Suppose that \mdline{262}$\{ f_s \}$\mdline{262} is a collection of secure pseudorandom functions where \mdline{262}$f_s$\mdline{262} maps \mdline{262}$\zo^{|s|+1}$\mdline{262} to \mdline{262}$\zo$\mdline{262}. For each of the following constructions \mdline{262}$f^1$\mdline{262},\mdline{262}$f^2$\mdline{262} below of function collections mapping \mdline{262}$\zo^{|s|}$\mdline{262} to \mdline{262}$\zo^2$\mdline{262}, either prove that they are necessarily secure or show a counterexample (i.e., a construction of PRF\mdline{262}'\mdline{262}s \mdline{262}$\{ f_s \}$\mdline{262} based on the PRF conjecture such that the corresponding construction is insecure)%mdk

%mdk-data-line={263}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,label=\alph*.]%mdk

%mdk-data-line={263}
\item\mdline{263}(10 points) \mdline{263}$f^1_s(x)=f_s(0\circ x) \circ f_s(1\circ x)$\mdline{263} 

%mdk-data-line={264}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={265}
\noindent\mdline{265}\textbf{Proof}.  \mdline{265}Intuitively, this is a valid and secure construction. The reason for this is that no matter what the
chosen \mdline{266}$x$\mdline{266} attacks on \mdline{266}$f^1_s$\mdline{266} are, we always see the pairs of values \mdline{266}$f_s(0 \circ x)$\mdline{266} and \mdline{266}$f_s(1 \circ x)$\mdline{266}
which are completely unrelated by the security of \mdline{267}$f_s$\mdline{267}. More formally,
Assume \mdline{268}$\{f^1_s\}$\mdline{268} is not a PRF.  Then there exist a computationally efficient adversary \mdline{268}$A^1$\mdline{268} such
that for random seed \mdline{269}$s$\mdline{269}:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={272}
|\E_{s \gets_R \zo^{|s|}} [A^{f^1_s(\cdot)}(1^{|s|})] - \E_{H^1 \gets \zo^{|s|} \to \zo^2}[A^{H^1}](1^{|s|}) | < \epsilon
\]%mdk
\mdline{274}Then note that we can use \mdline{274}$A^1$\mdline{274} to construct an adversary \mdline{274}$A$\mdline{274} the breaks \mdline{274}$\{f_s\}$\mdline{274}. The construction
is simple as \mdline{275}$A$\mdline{275} simply simulates \mdline{275}$A^1$\mdline{275} and captures the queries it sends to its black box 
\mdline{276}$B^1_s(\cdot): \zo^{|s|} \to \zo^2$\mdline{276} and transforms them into queries to \mdline{276}$A$\mdline{276}'\mdline{276}s black box, 
\mdline{277}$B_s(\cdot):\zo^{|s| + 1} \to \zo$\mdline{277}. On any query \mdline{277}$i \in [2^{|s|}]$\mdline{277} by \mdline{277}$A^1$\mdline{277}, \mdline{277}$A$\mdline{277} forwards two queries
to \mdline{278}$B_s(\cdot)$\mdline{278}, the first being \mdline{278}$i$\mdline{278} and the second \mdline{278}$i + 2^{|s|}$\mdline{278}, outputting two bits, and then
returns the value \mdline{279}$B_s(i) \cdot B_s(i + 2^{|s|})$\mdline{279} as the answer to \mdline{279}$A^1$\mdline{279}. When \mdline{279}$A^1$\mdline{279} is finished,
\mdline{280}$A$\mdline{280} simply returns the result of \mdline{280}$A^1$\mdline{280}. Then note that if \mdline{280}$B_s(\cdot)$\mdline{280} is instantiated with 
an \mdline{281}$f_s$\mdline{281} for random \mdline{281}$s$\mdline{281}, then \mdline{281}$A$\mdline{281} simulates to \mdline{281}$A^1$\mdline{281} exactly the conversations that \mdline{281}$A^1$\mdline{281} would
have had with the function \mdline{282}$f^1_s$\mdline{282}. On the other hand, if \mdline{282}$B_s(\cdot)$\mdline{282} is a completely random
function \mdline{283}$r: \zo^{|s|+1} \to \zo$\mdline{283}, then the simulation by \mdline{283}$A$\mdline{283} is that of a completely random function.
Therefore:
\noindent\noindent\[%mdk-data-line={286}
|\E_{s \gets_R \zo^{|s|}} [A^{f_s(\cdot)}(1^{|s|+1})] - \E_{H \gets \zo^{|s|+1} \to \zo}[A^{H}](1^{|s|+1}) | < \epsilon
\]%mdk
\mdline{288}\mdfloatright{\ensuremath{\Box}}\mdline{288}%mdk

%mdk-data-line={289}
\item\mdline{289}(10 points) \mdline{289}$f^2_s(x)=f_s(0\circ x) \circ f_s(x\circ 1)$\mdline{289}

%mdk-data-line={290}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={291}
\noindent\mdline{291}\textbf{Proof}.  \mdline{291}The construction is not secure. We directly construct an computationally efficient
adversary \mdline{292}$A$\mdline{292} that can distinguish between
a completely random function \mdline{293}$H \gets [2^{|s|}] \to \zo^2$\mdline{293} and a function \mdline{293}$f^2_s$\mdline{293} selected 
from our collection for random \mdline{294}$s$\mdline{294}. On input \mdline{294}$1^{|s|}$\mdline{294}, \mdline{294}$A$\mdline{294} queries its box \mdline{294}$B_s(\cdot)$\mdline{294} with inputs
\mdline{295}$i \in [2^{|s|-1} - 1]$\mdline{295} and \mdline{295}$2*i + 1$\mdline{295} to obtain \mdline{295}$x = B_s(i)$\mdline{295} and \mdline{295}$y = B_s(2*i+1)$\mdline{295}. It then
checks to see if \mdline{296}$x_2 = y_1$\mdline{296} (the last bit of the first result matches the first bit of the 
last result). If that is the case, then it outputs \mdline{297}$1$\mdline{297}, otherwise \mdline{297}$0$\mdline{297}. Note that for our given
construction \mdline{298}$f^1$\mdline{298}, the last bit of the \mdline{298}$f^2(i)$\mdline{298} always matches the first bit of \mdline{298}$f^2(2i+1)$\mdline{298}. 
The reason for this is clear. Let \mdline{299}$x$\mdline{299} be the bit representation of \mdline{299}$i$\mdline{299}. Then note that 
\mdline{300}$0 \circ x$\mdline{300} is still just \mdline{300}$i$\mdline{300}, and \mdline{300}$x \circ 1$\mdline{300} is really \mdline{300}$i << 1 + 1$\mdline{300} (right shift \mdline{300}$i$\mdline{300} and add \mdline{300}$1$\mdline{300})
, which is equivalent to \mdline{301}$2*i + 1$\mdline{301}. Therefore, \mdline{301}$f^2(i) = f(i) \circ f(2i + 1)$\mdline{301} and 
\mdline{302}$f^2(2i + 1) = f(2i + 1) \circ f(4i + 3)$\mdline{302}. However, in the case where \mdline{302}$B_s(\cdot)$\mdline{302} is a completely 
random function, then \mdline{303}$x_2 = y_1$\mdline{303} with probability \mdline{303}$\frac{1}{2}$\mdline{303}. Therefore:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={306}
|\E_{s \gets \zo^{|s|}}[A^{f^2_s(\cdot)}(1^{|s|})] - \E_{H \gets [2^{|s|}] \to \zo^2}[A^H(1^{|s|})] | = |1 - \frac{1}{2}| = \frac{1}{2}
\]%mdk
\mdline{308}which is non-negligible. Furthermore, note that \mdline{308}$A$\mdline{308} makes simply two queries to its black box
and compares two bits, which implies it is therefore computationally efficient.%mdk
%mdk
\end{enumerate}%mdk%mdk

%mdk-data-line={312}
\item{}
%mdk-data-line={312}
\mdline{312}(25 points) For the sake of this question, let\mdline{312}'\mdline{312}s say that a pair of algorithms \mdline{312}$(S,V)$\mdline{312} is an \mdline{312}\emph{enhanced message authentication code}\mdline{312} if it is a secure message authentication code (as per the definition given in the lecture notes) with the following addition\mdline{312}\textemdash{}\mdline{312} in the attack game Mallory is given not just oracle (i.e., black box) access to the signing oracle \mdline{312}$S$\mdline{312} but also to the verification oracle \mdline{312}$V$\mdline{312}. That is, Mallory can put forward a pair \mdline{312}$(m,\sigma)$\mdline{312} to the oracle and find out whether or not the pair passes verification. Prove that every \mdline{312}$(S,V)$\mdline{312} that is a secure message authentication code is also an enhance message authentication code.%mdk

%mdk-data-line={313}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={314}
\noindent\mdline{314}\textbf{Proof}.  \mdline{314}We assume a shared private key. 
We proof by contradiction. Suppose we have a pair of algorithms such that \mdline{315}$(S,V)$\mdline{315} is a secure
message authentication code but is \mdline{316}\emph{not}\mdline{316} an enhanced message authentication code. Therefore,
there exists an adversary \mdline{317}$A$\mdline{317} which for random, unknown key \mdline{317}$k$\mdline{317}
queries \mdline{318}$S_k(\cdot)$\mdline{318} and \mdline{318}$V_k(\cdot)$\mdline{318} some polynomial
number of times and outs the message \mdline{319}$(m',\tau')$\mdline{319} un-queried such that \mdline{319}$V_k(m',\tau') = 1$\mdline{319}. Then we
can use this adversary to construct and adversary \mdline{320}$A'$\mdline{320} with access only to \mdline{320}$S_{k'}(\cdot)$\mdline{320}
for some random and unknown key \mdline{321}$k'$\mdline{321} as follows.
The adversary \mdline{322}$A'$\mdline{322} simulates \mdline{322}$A$\mdline{322}. When \mdline{322}$A$\mdline{322} queries the signing oracle with message \mdline{322}$m$\mdline{322}, \mdline{322}$A$\mdline{322} forwards
the message to its own oracle \mdline{323}$S_{k'}$\mdline{323} and gives the result to \mdline{323}$A$\mdline{323}. When \mdline{323}$A$\mdline{323} attempts to query
the verification oracle \mdline{324}$V_k(\cdot)$\mdline{324}, \mdline{324}$A$\mdline{324} takes the input \mdline{324}$(m,\tau)$\mdline{324}, and obtains the tag
\mdline{325}$\tau_r = S_{k'}(m)$\mdline{325} and then compares \mdline{325}$\tau_r$\mdline{325} and \mdline{325}$\tau$\mdline{325}. If equal, it gives \mdline{325}$1$\mdline{325} to \mdline{325}$A$\mdline{325}. Otherwise,
it gives \mdline{326}$0$\mdline{326} to \mdline{326}$A$\mdline{326}. Then \mdline{326}$A$\mdline{326} outputs whatever \mdline{326}$(m',\tau')$\mdline{326} \mdline{326}$A'$\mdline{326} comes up at the end of its\mdline{326}'\mdline{326} 
computation. Note that the verification procedure carried out by \mdline{327}$A'$\mdline{327} is always correct (it
verifies the message as a true verification procedure would). Therefore, from the perspective of
\mdline{329}$A$\mdline{329}, it is interacting with \mdline{329}$(S_{k'}, V_{k'})$\mdline{329}. Since we assumed that \mdline{329}$A$\mdline{329} can break this 
enhanced security, we know that \mdline{330}$V_{k'}(m',\tau') = 1$\mdline{330}. However, this breaks the MAC assumption
of \mdline{331}$(S,V)$\mdline{331}, a contradiction.%mdk%mdk
\end{mdbmarginx}%mdk

%mdk-data-line={333}
\mdline{333}\mdfloatright{\ensuremath{\Box}}\mdline{333}%mdk%mdk
%mdk
\end{enumerate}%mdk%mdk


\end{document}
