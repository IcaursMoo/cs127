\documentclass{article}
% generated by Madoko, version 1.0.0-rc6
%mdk-data-line={1}


\usepackage[heading-base={2},section-num={False},bib-label={True}]{madoko2}


\begin{document}



%mdk-data-line={1}
\noindent\mdline{1}\% Homework 10: Public key crypto review%mdk
%mdk-data-line={4}

\newcommand{\zo}{\{0,1\}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\getsr}{\leftarrow_R\;}
\newcommand{\Gp}{\mathbb{G}}
\newcommand{\iprod}[1]{\langle #1 \rangle}
\newcommand{\Epubcca}{E^{pub,cca}}
\newcommand{\Epubcpa}{E^{pub,cpa}}
\newcommand{\Epriv}{E^{priv,cca}}
\newcommand{\Sign}{S}
\newcommand{\Ver}{V}

\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}

\newcommand{\cF}{\mathcal{F}}

\newcommand{\onand}{\overline{\wedge}}
%mdk-data-line={25}
\subsubsection{\mdline{25}0.0.1.\hspace*{0.5em}\mdline{25}Total of 120 points}\label{sec-total-of-120-points}%mdk%mdk

%mdk-data-line={27}
\noindent\mdline{27}(Most of this exercise is a review exercise on some of the notions we have encountered before.)%mdk

%mdk-data-line={29}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={29}
\item{}
%mdk-data-line={29}
\mdline{29}(25 points) Suppose that there exists an efficient algorithm \mdline{29}$A$\mdline{29} that on input \mdline{29}$m$\mdline{29} and \mdline{29}$a \in \Z^*_m$\mdline{29} outputs the smallest number \mdline{29}$r$\mdline{29} such that \mdline{29}$a^r = 1 (\mod m)$\mdline{29}. Prove that under this assumption there is an efficient (probabilistic) algorithm \mdline{29}$B$\mdline{29} that on input \mdline{29}$m=pq$\mdline{29} with \mdline{29}$q (\mod 4) = p (\mod 4)=3$\mdline{29}, outputs \mdline{29}$p$\mdline{29} and \mdline{29}$q$\mdline{29}. You can follow the outline of the lecture notes, or see the footnote for hint on another approach\mdline{29}\mdfootnote{1}{%mdk-data-line={75}
%mdk-data-line={75}
\noindent\mdline{75}For starters, you can  assume for partial credit the following claim: with probability at least \mdline{75}$1/100$\mdline{75}, if we pick a random \mdline{75}$a\in \Z^*_m$\mdline{75} then \mdline{75}$a$\mdline{75} will have an even order and \mdline{75}$a^{r/2} \neq -1 (\mod m)$\mdline{75}. Using the claim you can reduce factoring to order finding in a similar way to how we reduced factoring to finding square roots. For full credit, prove the claim by first proving using the chinese remainder theorem that for every \mdline{75}$a$\mdline{75}, the order of \mdline{75}$a$\mdline{75} modulo \mdline{75}$m$\mdline{75} is the least common multiple of the order of \mdline{75}$a$\mdline{75} modulo \mdline{75}$P$\mdline{75} and the order of \mdline{75}$a$\mdline{75} modulo \mdline{75}$q$\mdline{75}, and then use the fact that for every group \mdline{75}$G$\mdline{75}, if \mdline{75}$G' \neq G$\mdline{75} is a subgroup of \mdline{75}$G$\mdline{75} then \mdline{75}$|G|/|G'| \geq 2$\mdline{75}.%mdk
\label{fn-hint}%mdk%mdk
}\mdline{29}%mdk
\mdline{31}We present the proof in two forms. First following the details from lecture. 
We define the efficient, probabilistic algorithm \mdline{32}$B$\mdline{32} to do the following. On input \mdline{32}$m = pq$\mdline{32}, it selects
a random \mdline{33}$g \in \Z_m^*$\mdline{33}. It then passes this \mdline{33}$g$\mdline{33} as input into \mdline{33}$A$\mdline{33} such that \mdline{33}$r = A(g)$\mdline{33} where \mdline{33}$r = order(g)$\mdline{33}. 
From this result, \mdline{34}$B$\mdline{34} then calculates the values \mdline{34}$s = m + 1 - r$\mdline{34} and solves the polynomial
\noindent\noindent\[%mdk-data-line={36}
x^2 - sx + m = 0 \pmod m
\]%mdk
\mdline{38}outputing the roots. The claim is that roots are the the factors \mdline{38}$p,q$\mdline{38} of
\mdline{39}$m$\mdline{39} with high probability. The first step in proving this claim is demonstrating that with high
probability, the element \mdline{40}$g$\mdline{40} that is chose at random from \mdline{40}$\Z_m^*$\mdline{40} is a generator of \mdline{40}$\Z_m^*$\mdline{40} and 
therefore we have that \mdline{41}$r = order(g) = |Z_m^*|$\mdline{41}.

%mdk-data-line={42}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={43}
\noindent\mdline{43}\textbf{Proof}.  \mdline{43} The proof is relatively straight forward. The element \mdline{43}$g$\mdline{43} is chosen uniformly at random. We know from
 the definition of \mdline{44}$|Z_m^*|$\mdline{44} that for all \mdline{44}$a \in Z_m^*$\mdline{44}, \mdline{44}$a^{|Z_m^*|} = 1 \pmod m$\mdline{44}. Therefore, the
 order of \mdline{45}$a$\mdline{45} must be a divisor of \mdline{45}$|Z_m^*|$\mdline{45}. Note that \mdline{45}$|Z_m^*|$\mdline{45} has at most \mdline{45}$\log |Z_m^*|$\mdline{45} divisors,
 and as such, the probability that \mdline{46}$order(a) = d$\mdline{46} where \mdline{46}$d \mid |Z_m^*|$\mdline{46} and \mdline{46}$d \neq Z_m^*|$\mdline{46} is at least
 \mdline{47}$1 - \frac{\log |Z_m^*| }{|Z_m^*|}$\mdline{47} (as an upper bound on the number of factors, suppose all factors
 are \mdline{48}$2$\mdline{48}, then there are at most \mdline{48}$\log |Z_m^*|$\mdline{48} such factors). Therefore, we have that with a 
 high likelihood, the random element
 \mdline{50}$g$\mdline{50} that we have selected is a generator of the group \mdline{50}$Z_m^*$\mdline{50}. If we wish to increase the likelihood
 of this occurring, we can simply select multiple \mdline{51}$g_i$\mdline{51} at random from \mdline{51}$Z_m^*$\mdline{51} and take their 
 least common multiple. Note that all \mdline{52}$g_i$\mdline{52} are divisors of \mdline{52}$|Z_m^*|$\mdline{52} and therefore, the likelihood
 only increases if we take their LCM.  However, as we can see from the above, this is not strictly
 necessary since for large \mdline{54}$m$\mdline{54}, the likelihood that \mdline{54}$g$\mdline{54} selected at random is a generator of \mdline{54}$|Z_m|$\mdline{54}
 is at least \mdline{55}$1 - negl$\mdline{55} since \mdline{55}$\log x << x$\mdline{55} for large \mdline{55}$x$\mdline{55}. 
\mdline{56} \mdfloatright{\ensuremath{\Box}}\mdline{56}%mdk%mdk
\end{mdbmarginx}%mdk
\mdline{60}Given the above, we have the with high likelihood, \mdline{60}$r = |Z_m^*|$\mdline{60}. Now we complete the proof by showing
that the process outlined above will recover \mdline{61}$p,q$\mdline{61}. 

%mdk-data-line={62}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={63}
\noindent\mdline{63}\textbf{Proof}.  \mdline{63}Given that \mdline{63}$r = |Z_m^*| = (p-1)(q-1) = pq - p - q + 1$\mdline{63}, we first note that \mdline{63}$s = m + 1 - r = pq + 1 - pq + p + q - 1 = p + q$\mdline{63}. 
Therefore the defined polynomial is in fact \mdline{64}$x^2 - (p+q)x + pq = 0$\mdline{64}, which factors into \mdline{64}$(x-p)(x-q)$\mdline{64},
therefore the roots of the polynomial are \mdline{65}$p,q$\mdline{65} as desired. Note that the polynomial can be solved
quickly simply using the quadratic formula.\mdline{66}  
\mdfloatright{\ensuremath{\Box}}%mdk%mdk
\end{mdbmarginx}%mdk
\mdline{70}The above claims put together complete the proof. Therefore, given the adversary \mdline{70}$A$\mdline{70} which can efficiently
solve the order finding problem, we can construct an adversary \mdline{71}$B$\mdline{71} that can efficiently factor \mdline{71}$m$\mdline{71}
with high probability. Note that \mdline{72}$B$\mdline{72} is efficient because it uses \mdline{72}$A$\mdline{72} to find \mdline{72}$r$\mdline{72} (and \mdline{72}$A$\mdline{72} is efficient),
and other than that simply computes the roots of a quadratic polynomial, which can be done efficiently.%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={77}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,start=2]%mdk

%mdk-data-line={77}
\item\mdline{77}(50 points) Consider the following proof system for Alice to prove to Bob that a graph is 3 colorable:

%mdk-data-line={78}
\begin{itemize}%mdk

%mdk-data-line={78}
\item{}
%mdk-data-line={78}
\mdline{78}\textbf{Common input:}\mdline{78} Graph \mdline{78}$G=(V,E)$\mdline{78} on \mdline{78}$n$\mdline{78} vertices.%mdk%mdk

%mdk-data-line={80}
\item{}
%mdk-data-line={80}
\mdline{80}\textbf{Alice (Prover) private input:}\mdline{80} A function \mdline{80}$f:V\rightarrow \{1,2,3\}$\mdline{80} such that \mdline{80}$f(i)\neq f(j)$\mdline{80} for every \mdline{80}$\{i,j\}\in E$\mdline{80}.%mdk%mdk

%mdk-data-line={82}
\item{}
%mdk-data-line={82}
\mdline{82}\textbf{Step 1: Alice \textless{}- Bob:}\mdline{82} Bob selects \mdline{82}$z,z' \getsr \zo^{10n}$\mdline{82} and sends \mdline{82}$z$\mdline{82} to Alice.%mdk%mdk

%mdk-data-line={83}
\item{}
%mdk-data-line={83}
\mdline{83}\textbf{Step 2: Alice -\textgreater{} Bob:}\mdline{83} Alice selects \mdline{83}$\pi$\mdline{83} to be a random permutation over \mdline{83}$\{1,2,3\}$\mdline{83} and defines the functions \mdline{83}$f':V\rightarrow \{1,2,3\}$\mdline{83} as \mdline{83}$f'(i)=\pi(f(i))$\mdline{83}. For \mdline{83}$i=1..n$\mdline{83}, Alice chooses  \mdline{83}$w_i \getsr \zo^n$\mdline{83} and sends to Bob \mdline{83}$y_i = PRG(w_i)+f'(i)z +(f'(i) \mod\; 3)z' (\mod 2)$\mdline{83} where \mdline{83}$PRG:\zo^n\rightarrow\zo^{10n}$\mdline{83} is a pseudorandom generator and vector addition and vector/scalar multiplication are defined as usual.%mdk%mdk

%mdk-data-line={84}
\item{}
%mdk-data-line={84}
\mdline{84}\textbf{Step 3: Bob \textless{}- Alice:}\mdline{84} Bob selects a random edge  \mdline{84}$\{i,j \} \in E$\mdline{84} and sends \mdline{84}$i$\mdline{84} and \mdline{84}$j$\mdline{84} to Alice.%mdk%mdk

%mdk-data-line={85}
\item{}
%mdk-data-line={85}
\mdline{85}\textbf{Step 4: Alice -\textgreater{} Bob:}\mdline{85} Alice checks that \mdline{85}$\{i,j\}\in E$\mdline{85} (otherwise she aborts) and if so sends the strings \mdline{85}$w_i,w_j$\mdline{85} and the values \mdline{85}$f'(i),f'(j)$\mdline{85}.%mdk%mdk

%mdk-data-line={86}
\item{}
%mdk-data-line={86}
\mdline{86}\textbf{Bob's decision:}\mdline{86} Bob accepts the proof iff \mdline{86}$f'(i),f'(j)$\mdline{86} as sent by Alice are two distinct numbers in \mdline{86}$\{1,2,3\}$\mdline{86} and the strings she sent satisfy the equations \mdline{86}$y_i = PRG(w_i)+f'(i)z +(f'(i) \mod\; 3)z' (\mod 2)$\mdline{86}  and \mdline{86}$y_j = PRG(w_j)+f'(j)z +(f'(j) \mod\; 3)z' (\mod 2)$\mdline{86}%mdk%mdk
%mdk
\end{itemize}%mdk%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={88}
\noindent\mdline{88}Prove that this system is a zero knowledge proof system for the 3 coloring problem by showing the following:%mdk

%mdk-data-line={90}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,label=\alph*.]%mdk

%mdk-data-line={90}
\item\mdline{90}(Completeness, 10 points): Prove that if Alice and Bob are given inputs as above and both follow the protocol then Bob will accept the proof with probability \mdline{90}$1$\mdline{90}.

%mdk-data-line={91}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={92}
\noindent\mdline{92}\textbf{Proof}.  \mdline{92}First, note that if will not abort since Bob is following the protocol, so he will send the random edge 
\mdline{93}$\{i,j\} \in E$\mdline{93}. Therefore, we can assume that Bob received \mdline{93}$f'(i)$\mdline{93} and \mdline{93}$f'(j)$\mdline{93}. By the honesty of 
Alice, we know \mdline{94}$f'(i) = \pi(f(i))$\mdline{94} and \mdline{94}$f'(j) = \pi(f(j))$\mdline{94}. We also know that \mdline{94}$f(i) \neq f(j)$\mdline{94} since
\mdline{95}$\{i,j\} \in E$\mdline{95}, and since \mdline{95}$\pi$\mdline{95} is bijective, it follows that \mdline{95}$f'(i) \neq f'(j)$\mdline{95}. We now show that
the strings sent by Alice, \mdline{96}$w_i,w_j$\mdline{96}, satisfy the equations. This follows immediately from the 
honesty of both Alice and Bob since for all \mdline{97}$k = 1\cdots n$\mdline{97} Alice calculated 
\mdline{98}$y_k = PRG(w_k) + f'(i)z + (f'(i) \mod 3)z'( mod 2)$\mdline{98} with the honest values \mdline{98}$z,z'$\mdline{98} sent by Bob. Therefore,
when Bob computes the values \mdline{99}$y_i$\mdline{99} and \mdline{99}$y_j$\mdline{99} for the choses \mdline{99}$i,j$\mdline{99} using the random \mdline{99}$w_i,w_j$\mdline{99} given by
Alice (which, by honesty of Alice, are the corresponding values she used to make her own calculations),
we will have that \mdline{101}$y_i = PRG(w_i) + (f'(i) \mod 3)z'( \mod 2)$\mdline{101} and \mdline{101}$y_j = PRG(w_j) + (f'(j)\mod 3)z'(\mod 2)$\mdline{101}. 
\mdline{102}\mdfloatright{\ensuremath{\Box}}%mdk%mdk
\end{mdbmarginx}%mdk%mdk

%mdk-data-line={104}
\item\mdline{104}(Soundness, 15 points): Prove that if there exists no 3-coloring for \mdline{104}$G$\mdline{104} (i.e., for every coloring of \mdline{104}$G$\mdline{104}'\mdline{104}s vertices in \mdline{104}$\{1,2,3\}$\mdline{104} there is some edge \mdline{104}$\{i,j\}$\mdline{104} such that both \mdline{104}$i$\mdline{104} and \mdline{104}$j$\mdline{104} receive the same color), then with probability at least \mdline{104}$1/(10n^2)$\mdline{104} Bob  will reject the proof. (This probability can be amplified to more than \mdline{104}$1-2^{-k}$\mdline{104} by \mdline{104}$100kn^2$\mdline{104} repetitions).

%mdk-data-line={105}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={106}
\noindent\mdline{106}\textbf{Proof}.  \mdline{106}For soundness, we assume the honesty of Bob but not of Alice (therefore Alice can do anything she
wants). If Alice aborts, Bob will reject with probability \mdline{107}$1$\mdline{107}, therefore Alice will chose not to abort.
Again, if Alice sends \mdline{108}$z_i = f(i), z_j = f(j)$\mdline{108} such that \mdline{108}$z_i = z_j$\mdline{108}, Bob will reject, so Alice must
send \mdline{109}$z_i \neq z_j$\mdline{109}. Given that the graph is not \mdline{109}$3$\mdline{109}-colorable, then with probability at most \mdline{109}$\frac{{n \choose 2} - 1}{{n \choose}}$\mdline{109}
Bob will choose an edge \mdline{110}$\{i,j\} \in E$\mdline{110} such that \mdline{110}$f'(i) \neq f'(j)$\mdline{110}. In this scenario, if Alice follows
the protocol, then Bob will accept. Note that in step 2, Alice commits to her choice of \mdline{111}$f'(i)$\mdline{111} for 
every \mdline{112}$i$\mdline{112} in the graph \mdline{112}$G$\mdline{112}. By the security of PRGs, she has committed to a particular coloring of 
each vertex. Note that if \mdline{113}$G$\mdline{113} is not \mdline{113}$3$\mdline{113}-colorable, then there exists some \mdline{113}$\{i,j\} \in E$\mdline{113} such that
\mdline{114}$f'(i) = f'(j)$\mdline{114} committed (otherwise Alice would have found a three coloring of the original graph). Therefore
no matter what Alice does, the messages she sends to Bob in Step 2 commit her to some coloring 
and to some permutation \mdline{116}$f'$\mdline{116} of the
graph \mdline{117}$G$\mdline{117} where for at least one \mdline{117}$\{i,j\} \in E$\mdline{117}, we will have that \mdline{117}$f'(i) \neq f'(j)$\mdline{117}. Now Bob will
randomly select this pair of \mdline{118}$\{i,j\}$\mdline{118} with probability at least \mdline{118}$\frac{1}{{n \choose 2}} > \frac{1}{10n^2}$\mdline{118}.
Then during step 4, if Alice sends the true values of \mdline{119}$f'(i) $\mdline{119} and \mdline{119}$f'(j)$\mdline{119}, then Bob will reject.
However, Alice cannot send different values, since in that case, Bob will reject because the equations
will no longer be satisfied. Note that a malicious Alice can attempt to modify \mdline{121}$f'(i)$\mdline{121} into \mdline{121}$i_{fake}$\mdline{121} (WLOG) by
sending a \mdline{122}$w_{fake}$\mdline{122} such that \mdline{122}$y_i = PRG(w_{fake}) + i_{fake}z + (i_{fake} \mod 3)z' (\mod 2) = PRG(w_{i}) + f'(i)z + (f'(i) \mod 3)z'(\mod 2)$\mdline{122}
which, involves finding a particular input \mdline{123}$w_{fake}$\mdline{123} such that:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={126}
PRG(w_{fake}) = \underbrace{PRG(w_i)}_{\text{Alice}} + \underbrace{f'(i)z + (f'(i)z  \mod 3)z' (\mod 2)}_{\text{randomized by Bob}} - \underbrace{i_{fake}z - (i_{fake} \mod 3)z' (\mod 2)}_{\text{also randomized by Bob}}   
\]%mdk
\mdline{128}Even with an exhaustive search of all possible inputs, given that \mdline{128}$PRG: \zo^n \to \zo^{10n}$\mdline{128}, the 
likelihood of such a \mdline{129}$w_{fake}$\mdline{129} existing is at most \mdline{129}$\frac{2^n}{2^{10n}} = \frac{1}{2^{9n}}$\mdline{129} which
is negligible. Therefore, only with probability \mdline{130}$\frac{1}{2^{9n}}$\mdline{130} will a malicious Alice succeed
in tricking Bob in this scenario. We therefore have that the probability of Bob accepting given
that \mdline{132}$G$\mdline{132} is not 3-colorable is
\noindent\noindent\[%mdk-data-line={134}
\Pr[Bob accepts] \leq \frac{{n \choose 2} - 1}{{n \choose 2}} + \frac{1}{{n \choose 2}}\frac{1}{2^{9n}} 
\]%mdk
\mdline{136}which implies that Bob will reject with probability:
\noindent\noindent\[%mdk-data-line={138}
\begin{aligned}
\Pr[Bob rejects] &\geq 1 - 1 + \frac{1}{{n \choose 2}} = \frac{1}{{n \choose 2}2^{9n}} \\
&= \frac{1}{{n \choose 2}}(1 - \frac{1}{2^{9n}}) \\
& \geq \frac{1}{10n^2}
\end{aligned}    
\]%mdk
\mdline{144}The above completes the proof for soundness.%mdk

%mdk-data-line={145}
\item\mdline{145}(Zero knowledge, 25 points) Prove that for every polynomial-time strategy \mdline{145}$B^*$\mdline{145} used by Bob, there exists an efficient algorithm \mdline{145}$S^*$\mdline{145}, so that for every 3-colorable graph \mdline{145}$G$\mdline{145} and coloring \mdline{145}$f$\mdline{145}, the output of \mdline{145}$S^*(G)$\mdline{145} is computationally indistinguishabl from the transcript  \mdline{145}$B^*$\mdline{145} observes after interacting with the honest strategy of Alice on public input \mdline{145}$G$\mdline{145} and private input \mdline{145}$x$\mdline{145}. (For partial credit of 15 points, prove only \mdline{145}\emph{honest verifier zero knowledge}\mdline{145} : that the above holds when \mdline{145}$B^*$\mdline{145} is the honest strategy of Bob.)

%mdk-data-line={146}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={147}
\noindent\mdline{147}\textbf{Proof}.  \mdline{147}We prove the existence of the efficient algorithm \mdline{147}$S^*$\mdline{147} by construction. On input of the graph
\mdline{148}$G$\mdline{148}, the simulator does the following:%mdk

%mdk-data-line={150}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={150}
\item\mdline{150}Let \mdline{150}$z,z' \in \zo^{10n}$\mdline{150} be the first message received from B\mdline{150}\textasciicircum{}\mdline{150}*\mdline{150} on input \mdline{150}$G$\mdline{150}.%mdk

%mdk-data-line={151}
\item\mdline{151}Select a uniformly random function \mdline{151}$f': V \to \{1,2,3\}$\mdline{151}. Then using this \mdline{151}$f'$\mdline{151} (coloring),
compute the message as Alice normaly would: For \mdline{152}$i = 1\cdots n$\mdline{152}, chose \mdline{152}$w_i \gets_R \zo^n$\mdline{152} and
send to Bob \mdline{153}$y_i = PRG(w_i) + f'(i)z + (f'(i) \mod 3)z'(\mod 2)$\mdline{153} where \mdline{153}$PRG : \zo^n \to \zo^{10n}$\mdline{153}
is a PRG.%mdk

%mdk-data-line={155}
\item\mdline{155}Let \mdline{155}$\{i,j\}$\mdline{155} be the edge selected by \mdline{155}$B^*$\mdline{155} when given \mdline{155}$G$\mdline{155} and the \mdline{155}$\{y_i\}$\mdline{155} from above.%mdk

%mdk-data-line={156}
\item\mdline{156}If \mdline{156}$\{i,j\} \notin E$\mdline{156}, then we abort. Otherwise, check to see if \mdline{156}$f'(i) = f'(j)$\mdline{156}. If this is the
case, then go back to step 1.%mdk

%mdk-data-line={158}
\item\mdline{158}We compute the fourth message as just as Alice would. We send the strings \mdline{158}$w_i$\mdline{158} and \mdline{158}$w_j$\mdline{158} and
the values \mdline{159}$f'(i)$\mdline{159} and \mdline{159}$f'(j)$\mdline{159}.%mdk

%mdk-data-line={160}
\item{}
%mdk-data-line={160}
\mdline{160}Then output whatever \mdline{160}$B^*$\mdline{160} outputs given the \mdline{160}$G$\mdline{160} and the prior messages.%mdk%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={163}
\noindent\mdline{163}To prove that the above transcript is computationally indistinguishable from the transcript \mdline{163}$B^*$\mdline{163}
observes after interacting with Alice, we prove the following claims.%mdk

%mdk-data-line={166}
\mdline{166}Claim 1: The messages \mdline{166}$\{y_i\}$\mdline{166} computed by \mdline{166}$S^*$\mdline{166} are computationally indistinguishable from the
messages computed by Alice. The reason for this is because \mdline{167}$PRG$\mdline{167} is a pseudorandom number generator,
which means it\mdline{168}'\mdline{168}s output is computationally indistinguishable from \mdline{168}$U_{10n}$\mdline{168} . Therefore, even after adding some
other factors, the final output is still indistinguishable from \mdline{169}$U_{10n}$\mdline{169}. Therefore, the two
results from the simulators and from Alice are computationally indistinguishable since both
are indistinguishable from \mdline{171}$U_{10n}$\mdline{171}.%mdk

%mdk-data-line={173}
\mdline{173}Claim 2: The probability that \mdline{173}$f'(i) = f'(j)$\mdline{173} = \mdline{173}$\frac{1}{3}$\mdline{173}. The reason for this follows
from Claim 1. Given that the outputs are computationally indistinguishable from the uniform distribution, 
\mdline{175}$B^*$\mdline{175} learns nothing about the coloring so far (because \mdline{175}$B^*$\mdline{175} must be efficient). Therefore, it cannot use any information about
\mdline{176}$f$\mdline{176} when selecting its edge \mdline{176}$\{i,j\}$\mdline{176}. Then the probability that \mdline{176}$f'(i)$\mdline{176} collides with \mdline{176}$f'(j)$\mdline{176} given
that \mdline{177}$f'$\mdline{177} is a random function is exactly \mdline{177}$\frac{1}{3}$\mdline{177}. Note that this implies that our simulator
is efficient, since in expectation, it will repeat this process \mdline{178}$3$\mdline{178} times (a constant amount).%mdk

%mdk-data-line={180}
\mdline{180}Claim 3: The last message computed by \mdline{180}$S^*$\mdline{180} is computationally indistinguishable from the message
Alice computes. Note that this is immediate since we compute this message exactly as Alice would.%mdk

%mdk-data-line={183}
\mdline{183}With the above three claims in place, it\mdline{183}'\mdline{183}s immediately clear that the output of \mdline{183}$S^*(G)$\mdline{183} is
computationally indistinguishable from the transcript \mdline{184}$B^*$\mdline{184} would observe after interacting with 
Alice on the public input \mdline{185}$G$\mdline{185} and the private input \mdline{185}$x$\mdline{185}. Therefore, we conclude that the 
proof system is zero-knowledge.%mdk%mdk
\end{mdbmarginx}%mdk

%mdk-data-line={190}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,start=3]%mdk

%mdk-data-line={190}
\item\mdline{190}KL 11.17  (20 points)

%mdk-data-line={191}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={192}
\noindent\mdline{192}\textbf{Proof}.  \mdline{192}TODO%mdk%mdk
\end{mdbmarginx}%mdk%mdk
%mdk
\end{enumerate}%mdk%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={195}
\begin{enumerate}[,start=4]%mdk

%mdk-data-line={195}
\item{}
%mdk-data-line={195}
\mdline{195}KL 12.14 (10 points)%mdk

%mdk-data-line={196}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={197}
\noindent\mdline{197}\textbf{Proof}.  \mdline{197}
First, we have the scenario where Bob\mdline{198}'\mdline{198}s private key has been stolen. This means that some adversary exists
out there who can sign messges impersonating Bob. In this scenario, when the CA receives the message
requesting the revocation of the certificate, two possibilities exists. Either Bob (the real Bob) has
signed and sent the message, in which case the signature is actually verifying the identity and it is
perfectly okay for the CA to revoke the certificate (as it has been requested by the legitimate user). In the
other scenario, the message is actually signed by the adversary, Eve. However, in this scenario,
the correct course of action is also to revoke the certificate, as the fact that a message that did 
not originate from Bob is nonetheless signed using Bob\mdline{205}'\mdline{205}s private key is evidence of Bob\mdline{205}'\mdline{205}s private
key having been compromised. Therefore, we must revoke the certificate.%mdk

%mdk-data-line={208}
\mdline{208}Note that it is not necessary for the CA to verify Bob\mdline{208}'\mdline{208}s identity since, again, in the first scenario
Bob is the one sending the message (so identity verification is redundant) and in the second scenario,
Eve has successfully impersonated Bob which means the certificate has been compromised (so it must be
revoked) regardless of who requested the revocation. Note that a party other than Bob can only
send the message if it has successfully compromised Bob.%mdk%mdk
\end{mdbmarginx}%mdk%mdk

%mdk-data-line={215}
\item{}
%mdk-data-line={215}
\mdline{215}KL 13.17 (15 points)%mdk

%mdk-data-line={216}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={217}
\noindent\mdline{217}\textbf{Proof}.  \mdline{217}
This follows almost directly from the fact that square root extraction implies factoring. Note that with
plain Rabin, the decryptor functions as an efficient square-root extraction algorithm. We simply chose a
random \mdline{220}$x \in \Z_N^*$\mdline{220} and calculate \mdline{220}$c = x^2 \mod N$\mdline{220}. We then ask the decryption algorithm for the result,
\mdline{221}$\hat{x} = D_d(x^2)$\mdline{221}. Note that the decryption will return one of the four possible square roots of 
\mdline{222}$x^2$\mdline{222} (we know that \mdline{222}$x^2$\mdline{222} has at most four possible distinct square roots given the argument presented in lecture).
If we have \mdline{223}$x \neq \pm \hat{x}$\mdline{223}, then we are done. Otherwise, repeat the process until we obtain
an \mdline{224}$x \neq \pm \hat{x}$\mdline{224}. Note that \mdline{224}$x = \pm\hat{x}$\mdline{224} with probability \mdline{224}$\frac{1}{2}$\mdline{224} because \mdline{224}$x$\mdline{224} is distributed
uniformly among the four possible roots. This means that after \mdline{225}$k$\mdline{225} repetitions, the probability that 
we have failed to find an \mdline{226}$x,\hat{x}$\mdline{226} satisfying the requirements is \mdline{226}$\frac{1}{2^k}$\mdline{226}, which decreases
incredibly quickly.%mdk

%mdk-data-line={229}
\mdline{229}Therefore, let us assume we\mdline{229}'\mdline{229}ve found \mdline{229}$x \neq \hat{x}$\mdline{229} such that \mdline{229}$(\pm x)^2 = (\pm \hat{x})$\mdline{229}. Then note
that with probability \mdline{230}$\frac{1}{4}$\mdline{230}, it will be that \mdline{230}$gcd(x - \hat{x},m) = p$\mdline{230}. We can formally show
this by using the CRT. Note that \mdline{231}$\varphi(x) = (x,y)$\mdline{231} and \mdline{231}$\varphi(\hat{x}) = (\hat{x},\hat{y})$\mdline{231}. Then 
taking \mdline{232}$\varphi(x - \hat{x}) = (x,y) - (\hat{x},\hat{y}) = (0,2\hat{y})$\mdline{232} a quarter of the time. This implies that 
\mdline{233}$x-\hat{x} = 0 \hat{x} \pmod{p}$\mdline{233} and \mdline{233}$x - \hat{x} \neq 0 \pmod{q}$\mdline{233} which implies that \mdline{233}$x - \hat{x}$\mdline{233} is a
multiple of \mdline{234}$p$\mdline{234}, implying that \mdline{234}$gcd(x - \hat{x}, m) = p$\mdline{234} as desired. Therefore we have extracted the
value \mdline{235}$p$\mdline{235} and can now simply compute \mdline{235}$q = m /p$\mdline{235} and we have therefore, with high probability, recovered
the entire key!%mdk%mdk
\end{mdbmarginx}%mdk%mdk
%mdk
\end{enumerate}%mdk%mdk


\end{document}
