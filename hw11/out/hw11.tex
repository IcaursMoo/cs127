\documentclass{article}
% generated by Madoko, version 1.0.0-rc7
%mdk-data-line={1}


\usepackage[heading-base={2},section-num={False},bib-label={True}]{madoko2}


\begin{document}



%mdk-data-line={4}
\newcommand{\zo}{\{0,1\}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\getsr}{\leftarrow_R\;}
\newcommand{\Gp}{\mathbb{G}}
\newcommand{\iprod}[1]{\langle #1 \rangle}
\newcommand{\Epubcca}{E^{pub,cca}}
\newcommand{\Epubcpa}{E^{pub,cpa}}
\newcommand{\Epriv}{E^{priv,cca}}
\newcommand{\Sign}{S}
\newcommand{\Ver}{V}

\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}

\newcommand{\cF}{\mathcal{F}}

\newcommand{\onand}{\overline{\wedge}}

\newcommand{\cO}{\mathcal{O}}
%mdk-data-line={26}
\subsubsection{\mdline{26}0.0.1.\hspace*{0.5em}\mdline{26}Total of 170 points}\label{sec-total-of-170-points}%mdk%mdk

%mdk-data-line={28}
\begin{enumerate}%mdk

%mdk-data-line={28}
\item{}
%mdk-data-line={28}
\mdline{28}(50 points) Here is one possible security definition for a witness encryption scheme: it is composed of two efficient algorithms \mdline{28}$(E,D)$\mdline{28} with the following property. \mdline{28}$E$\mdline{28} is a probabilistic algorithm that takes as input a circuit \mdline{28}$C:\zo^n\rightarrow\zo$\mdline{28} and a message \mdline{28}$b\in\zo$\mdline{28} and outputs \mdline{28}$c=E_C(b)$\mdline{28}. \mdline{28}$D$\mdline{28} takes as input a string \mdline{28}$w$\mdline{28} and a ciphertext \mdline{28}$c$\mdline{28}, and the condition we require is that if \mdline{28}$C(w)=1$\mdline{28} then \mdline{28}$D_w(E_C(b))=b$\mdline{28}. The notion of security is that if there exists no \mdline{28}$w$\mdline{28} such that \mdline{28}$C(w)=1$\mdline{28} then the distributions \mdline{28}$E_C(0)$\mdline{28} and \mdline{28}$E_C(1)$\mdline{28} are computationally indistinguishable (the distributions are over the coins of the encryption algorithm).%mdk

%mdk-data-line={30}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,label=\alph*.]%mdk

%mdk-data-line={30}
\item{}
%mdk-data-line={30}
\mdline{30}(25 points) Prove that  under the PRG assumption, witness encryption implies a public key encryption scheme. See footnote for hint\mdline{30}\mdfootnote{1}{%mdk-data-line={87}
%mdk-data-line={87}
\noindent\mdline{87}The public key can be a string \mdline{87}$y=G(w)$\mdline{87} where \mdline{87}$G:\zo^n\rightarrow\zo^{2n}$\mdline{87} is a PRG, and the private key can be \mdline{87}$w$\mdline{87}.%mdk
\label{fn-hint}%mdk%mdk
}\mdline{30}%mdk

%mdk-data-line={32}
\mdline{32}We provide the construction for a CPA-secure public key one-bit encryption scheme. First, suppose
we have a secure witness encryption schme \mdline{33}$(E,D)$\mdline{33} as described previously. Then the public
encryption scheme is is \mdline{34}$(G',E',D')$\mdline{34}
where the \mdline{35}\emph{key generation algorithm}\mdline{35} \mdline{35}$G'$\mdline{35}, on input \mdline{35}$1^n$\mdline{35}, outputs the pair \mdline{35}$(e,d) = (PRG(w), w)$\mdline{35} where
\mdline{36}$w \in \zo^n$\mdline{36} is the private key \mdline{36}$PRG: \zo^n \to \zo^{2n}$\mdline{36} is a pseudorandom number
generator. On input \mdline{37}$b \in \zo$\mdline{37}, the encryptions algorithm \mdline{37}$E'_e(b)$\mdline{37} first constructs the circuit 
\mdline{38}$C': \zo^n \to \zo$\mdline{38} which works as follows. It has hard-coded the constant \mdline{38}$e$\mdline{38} (the public key used for encryption) and
then, on input \mdline{39}$x$\mdline{39}, \mdline{39}$C'(x) = 1$\mdline{39} if \mdline{39}$PRG(x) = e$\mdline{39} and \mdline{39}$0$\mdline{39} otherwise. With this circuit constructed,
the encryption \mdline{40}$E'_e(b) = E_C(b)$\mdline{40}. The decryption algorithm \mdline{40}$D'_d$\mdline{40} is then simply the same decryption
algorithm \mdline{41}$D$\mdline{41} used in witness encryption where \mdline{41}$d$\mdline{41} (the private encryption key) is fed as input to \mdline{41}$D$\mdline{41} along with
the encryption \mdline{42}$c = E'_e(b)$\mdline{42} produced earlier.%mdk

%mdk-data-line={44}
\mdline{44}Correctness of the above public key encryption scheme follows almost immediately. We have that
\mdline{45}$D'_d(c) = D'_d(E'_e(b)) = D_d(E_{C'}(b)) = b$\mdline{45} if \mdline{45}$C'(d) = 1$\mdline{45}, which is always the case since
\mdline{46}$C'(d)$\mdline{46} simply checks if \mdline{46}$PRG(d) = e$\mdline{46} which is true by construction of \mdline{46}$(e,d)$\mdline{46}.%mdk
\mdline{48}We now proof that the above encryption scheme is CPA-secure
under the PRG assumption. 

%mdk-data-line={50}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={51}
\noindent\mdline{51}\textbf{Proof}.  \mdline{51}We proof that \mdline{51}$\{ E'(0) \} \approx \{ E'(1) \}$\mdline{51}. Suppose this is not the case. Then there exists
a distinguisher \mdline{52}$D$\mdline{52} that can distinguish between the two distributions. Then we can use this distinguisher
to construct a distinguisher \mdline{53}$D'$\mdline{53} between \mdline{53}$PRG(U_n)$\mdline{53} and \mdline{53}$U_{2n}$\mdline{53}. The distinguisher \mdline{53}$D'$\mdline{53} works as 
follows:%mdk

%mdk-data-line={56}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={56}
\item\mdline{56}On input \mdline{56}$z \in \zo^n$\mdline{56}, \mdline{56}$D'$\mdline{56} takes \mdline{56}$z$\mdline{56} to be the private key for our public key encryption 
algorithm.%mdk

%mdk-data-line={58}
\item\mdline{58}$D'$\mdline{58} then picks \mdline{58}$b \in_R \zo$\mdline{58} and encrypts \mdline{58}$c = E'_z(b)$\mdline{58}.%mdk

%mdk-data-line={59}
\item\mdline{59}$D'$\mdline{59} then feeds this encryption to \mdline{59}$D$\mdline{59} so that we have \mdline{59}$b' = D(c)$\mdline{59}.%mdk

%mdk-data-line={60}
\item\mdline{60}If \mdline{60}$b' = b$\mdline{60}, \mdline{60}$D'$\mdline{60} ouputs \mdline{60}$1$\mdline{60} (indicating that the distribution is pseudorandom). Otherwise, \mdline{60}$D'$\mdline{60}
outputs \mdline{61}$0$\mdline{61} (indicating the distribution is uniformly random).%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={63}
\noindent\mdline{63}To analyze the ability of \mdline{63}$D'$\mdline{63} to distinguish between \mdline{63}$U_{2n}$\mdline{63} and \mdline{63}$PRG(U_n)$\mdline{63}, we note that if
\mdline{64}$z \in U_{2n}$\mdline{64}, then with probability \mdline{64}$\frac{2^{2n} - 2^n}{2^{2n}} = 1 - \frac{1}{2^{n}}$\mdline{64}, there does 
not exist a \mdline{65}$w$\mdline{65} such that \mdline{65}$C'(w) = 1$\mdline{65} (by construction),
and therefore by the definition of witness encryption, the distributions \mdline{66}$\{E_{C'}(0)\}$\mdline{66} and \mdline{66}$\{E_{C'}(1)\}$\mdline{66}
must be indistinguishable. Note that \mdline{67}$E_z'(b) = E_{C'}(b)$\mdline{67}. Therefore, in this case, \mdline{67}$b' = b$\mdline{67} with
probability at most \mdline{68}$\frac{1}{2} + \epsilon$\mdline{68} where \mdline{68}$\epsilon$\mdline{68} is negligible, and our distinguisher
\mdline{69}$D'$\mdline{69} then outputs 1 with probability at most \mdline{69}$\frac{1}{2} + \epsilon$\mdline{69}.%mdk

%mdk-data-line={71}
\mdline{71}Now suppose \mdline{71}$z = PRG(w)$\mdline{71} for some \mdline{71}$w \in \zo^n$\mdline{71}. Then by the assumption that a distinguisher \mdline{71}$D$\mdline{71} exists
and succeeds with non-negligible probability, note that our distinghisher \mdline{72}$D'$\mdline{72} will output \mdline{72}$1$\mdline{72} with the
same probability that \mdline{73}$D$\mdline{73} succeeds. Therefore, \mdline{73}$\Pr[D'(z) = 1] = \frac{1}{2} + p(n)$\mdline{73} where \mdline{73}$p(n)$\mdline{73} is
non-negligible. This leads us to the following conclusion.%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={77}
\begin{aligned}
|\E[D'(U_2n)] - E[D'(PRG(U_n)]| &\approx |\frac{1}{2^n}(\frac{1}{2} + p(n)) + (1 - \frac{1}{2^n})(\frac{1}{2} + \epsilon) - \frac{1}{2} + p(n)| \\
&= |\frac{p(n) - \epsilon}{2^n} + \epsilon - p(n)| \\
&=|-p(n) + negl| \\
&\approx p(n)
\end{aligned}
\]%mdk

%mdk-data-line={84}
\mdline{84}which is non-negligble. This contradict the PRG assumption. Therefore, it must be the case that our constructed
public key encryption scheme is CPA-secure.%mdk%mdk

%mdk-data-line={88}
\item{}
%mdk-data-line={88}
\mdline{88}(25 points) Give a construction of a witness encryption scheme using an indistinguishability obfuscator \mdline{88}$\cO$\mdline{88}. See footnote for hint\mdline{88}\mdfootnote{2}{%mdk-data-line={111}
%mdk-data-line={111}
\noindent\mdline{111}One can phrase the goal of the encryption algorithm in a witness encryption scheme as transforming the circuit \mdline{111}$C$\mdline{111} and message \mdline{111}$b$\mdline{111} to some \mdline{111}$C'$\mdline{111} that maps \mdline{111}$w$\mdline{111} to \mdline{111}$b$\mdline{111} if \mdline{111}$C(w)=1$\mdline{111} and maps \mdline{111}$w$\mdline{111} to \mdline{111}\mdcode{error}\mdline{111} (that can be encoded in some for, e.g., as  \mdline{111}$0$\mdline{111}) if \mdline{111}$C(w)=0$\mdline{111}. Of course one needs to ensure that it won\mdline{111}'\mdline{111}t be possible to extract \mdline{111}$b$\mdline{111} from \mdline{111}$C$\mdline{111} if there is no \mdline{111}$w$\mdline{111} satisfying \mdline{111}$C(w)=1$\mdline{111}.%mdk
\label{fn-hint2}%mdk%mdk
}\mdline{88}%mdk

%mdk-data-line={90}
\mdline{90}We give a construction for a secure witness encryption scheme. Suppose an indistinguishability 
obfuscator \mdline{91}$\cO$\mdline{91} exists. Then let \mdline{91}$(E,D)$\mdline{91} be the following witness encryption scheme. On input
\mdline{92}$C:\zo^n \to \zo,b$\mdline{92}, construct the circuit \mdline{92}$C_b:\zo^n \to \zo$\mdline{92} as follows. \mdline{92}$C_b(x) = b$\mdline{92} if \mdline{92}$C(x) = 1$\mdline{92} 
and \mdline{93}$C_b(x) = 0$\mdline{93} if \mdline{93}$C(x) \neq 1$\mdline{93}. Note that both \mdline{93}$b$\mdline{93} are hard-coded into \mdline{93}$C_b$\mdline{93}.\mdline{93}\mdbr
\mdline{94}Then output as a result \mdline{94}$c = E_C(b) = \cO(C_b)$\mdline{94}. The decryption algorithm, \mdline{94}$D$\mdline{94}, then works as follows. On input
\mdline{95}$w$\mdline{95} and ciphertext \mdline{95}$c$\mdline{95}, it feeds \mdline{95}$w$\mdline{95} to \mdline{95}$c$\mdline{95} and outputs the result.%mdk

%mdk-data-line={97}
\mdline{97}Correctness follows almost immediately from the fact that if \mdline{97}$C(w) = 1$\mdline{97} then \mdline{97}$D_w(c) = D_w(E_C(b)) = D_w(\cO(C_b)) = \cO(C_b)(w) = C_b(w) = b$\mdline{97}.%mdk
\mdline{99}We now proof that the encryption scheme is secure.

%mdk-data-line={100}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={101}
\noindent\mdline{101}\textbf{Proof}.  \mdline{101}We need to show that if there exists no \mdline{101}$w$\mdline{101} such that \mdline{101}$C(w) = 1$\mdline{101}, then \mdline{101}$\{ E_C(0) \} \approx \{E_C(1) \}$\mdline{101}.
This follows almost immediately by construction. Note that \mdline{102}$E_C(b) = \cO(C_b)$\mdline{102}. Then note that 
the only difference between \mdline{103}$b = 0$\mdline{103} and \mdline{103}$b = 1$\mdline{103} is the return bit when \mdline{103}$C(w) = 1$\mdline{103}, therefore 
\mdline{104}$C_0$\mdline{104} and \mdline{104}$C_1$\mdline{104} are the same size. Then note that if no \mdline{104}$w$\mdline{104} exists
such that \mdline{105}$C(w) = 1$\mdline{105}, then \mdline{105}$C_b$\mdline{105} contains a piece of dead code (returning \mdline{105}$b$\mdline{105}), and instead we have
\mdline{106}$C_b(x) = 0$\mdline{106} always. Therefore, \mdline{106}$C_0$\mdline{106} and \mdline{106}$C_b$\mdline{106} are two distinct circuits that have the same
size and compute the same function. Therefore we conclude that \mdline{107}$\cO(C_0)= E_C(0)$\mdline{107} and \mdline{107}$\cO(C_1) = E_C(1)$\mdline{107} are
two random variables that are computationally indistinguishable, therefore \mdline{108}$(E,D)$\mdline{108} is secure.%mdk%mdk
\end{mdbmarginx}%mdk%mdk
%mdk
\end{enumerate}%mdk%mdk

%mdk-data-line={113}
\item{}
%mdk-data-line={113}
\mdline{113}(60 points) A \mdline{113}\emph{puncturable PRF}\mdline{113} is a pseudorandom function collection \mdline{113}$\{ f_s \}$\mdline{113} such that for every input \mdline{113}$x^*$\mdline{113}, there is a way to map an index \mdline{113}$s$\mdline{113} into an index \mdline{113}$s^*=PUNCTURE(s,x^*)$\mdline{113} that allows to compute the function \mdline{113}$f_s$\mdline{113} on \mdline{113}\emph{every input except}\mdline{113} \mdline{113}$x^*$\mdline{113}. That is, there is some efficient algorithm \mdline{113}$EVAL$\mdline{113} such that \mdline{113}$EVAL(s^*,x)=f_s(x)$\mdline{113} for every \mdline{113}$x \neq x^*$\mdline{113} but such that even given \mdline{113}$s^*$\mdline{113}, the value \mdline{113}$f_s(x^*)$\mdline{113} is comptuationally indstinguishable  from a uniform value in \mdline{113}$\zo^n$\mdline{113}.%mdk

%mdk-data-line={115}
\begin{enumerate}[,label=\alph*.]%mdk

%mdk-data-line={115}
\item{}
%mdk-data-line={115}
\mdline{115}(30 points) Show that under the PRG assumption, there exists a puncturable PRF. See footnote for hint\mdline{115}\mdfootnote{3}{%mdk-data-line={243}
%mdk-data-line={243}
\noindent\mdline{243}Use the tree-based construction of PRFs we saw in class and show that by revealing some polynomial number of the labels of internal nodes instead of revealing the root,  one can provide information that is sufficient for evaluating the function on all inputs but one.%mdk
\label{fn-hint3}%mdk%mdk
}\mdline{115}%mdk

%mdk-data-line={117}
\mdline{117}We provide the construction of a puncturable PRF \mdline{117}$\{f_s\}$\mdline{117}, a mapping \mdline{117}$PUNCTURE$\mdline{117} of \mdline{117}$s,x^* \to s^*$\mdline{117}
and of an efficient algorithm \mdline{118}$EVAL$\mdline{118} as described above, explicitly.%mdk

%mdk-data-line={120}
\mdline{120}Consider a PRF \mdline{120}$G: \zo^n \to \zo^{2n}$\mdline{120}, which by the PRG assumptions, exists with the property 
that \mdline{121}$\{ U_{2n} \} \approx \{ G(U_n)\}$\mdline{121}. Then we construct the PRG family \mdline{121}$\{f_s\}$\mdline{121} using the 
tree-based construction described in lecture. For an explicit overview, refer to lecture notes,
but for the purposes of this proof, we now present a simple overview of the contruction.%mdk

%mdk-data-line={125}
\mdline{125}The construction can be pictorially imagined as a balanced binary tree. On input \mdline{125}$s$\mdline{125} (the secret key),
we let \mdline{126}$s \in \zo^n$\mdline{126} be the root node. Then when queried for the evaluation of \mdline{126}$f_s(x)$\mdline{126} for some \mdline{126}$x \in \zo^n$\mdline{126},
we perform a bit-expansion. Using \mdline{127}$G$\mdline{127}, we first compute \mdline{127}$G(s) = G_0(s) \| G_1(s)$\mdline{127} where \mdline{127}$G_0(s)$\mdline{127} is the
first \mdline{128}$n$\mdline{128}-bits and \mdline{128}$G_1(s)$\mdline{128} the last \mdline{128}$n$\mdline{128}-bits of the \mdline{128}$2n$\mdline{128}-bit output string, \mdline{128}$G(s)$\mdline{128}. We then take
\mdline{129}$G_{x_1}(s)$\mdline{129} to be the new root of a binary tree. We repeat the process with \mdline{129}$x_{2,\cdots,n}$\mdline{129}. We 
continue this until we have the last bit \mdline{130}$x_n$\mdline{130}, and at that point, we simply return \mdline{130}$G_{x_n}(G_{x_{n-1}}(\cdots G_{x_1}(s)))$\mdline{130}.
which is the final \mdline{131}\mdcode{}\mdline{131}root\mdline{131}\textquoteleft{}\textquoteright{}\mdline{131} we labeled.%mdk

%mdk-data-line={133}
\mdline{133}With the above construction in mind, we now define the function \mdline{133}$PUNCTURE: \zo^n \times \zo^n \to \zo^{n^2}$\mdline{133}.
It might be of some curiosity why we define the function \mdline{134}$PUNCTURE$\mdline{134} to output a string with \mdline{134}$n^2$\mdline{134} bits.
However, I was unable to figure out how to do this with \mdline{135}$n$\mdline{135} bits (as I believe is the intention?), and
feel like any improvements I came up with took away from the illustrative powers of the proof. Therefore,
I am going to \mdline{137}\emph{assume}\mdline{137} that producing an output index \mdline{137}$s^* \in \zo^{n^2}$\mdline{137} is appropriate. If this is
not the case, then the rest of the proof falls through. However, under this assumption, we now provide
a construction for \mdline{139}$PUNCTURE$\mdline{139}.%mdk

%mdk-data-line={141}
\mdline{141}$PUNCTURE$\mdline{141} works as follows. Given \mdline{141}$x^*$\mdline{141} and \mdline{141}$s$\mdline{141}, let \mdline{141}$x^* = x^*_1 x^*_2 \cdots x^*_n$\mdline{141} and let \mdline{141}$\bar{b} = b \oplus 1$\mdline{141}. 
Then let \mdline{142}$g_s: \zo^{\leq n} \to \zo^n$\mdline{142} be defined in the same way as \mdline{142}$f_s$\mdline{142} would be, but when given an
input of of length \mdline{143}$k \leq n$\mdline{143}, the result will be the internal node that\mdline{143}'\mdline{143}s last used as a root. For
example, \mdline{144}$g_s(0) = G_0(s)$\mdline{144}, and \mdline{144}$g_s(10) = G_0(G_1(s))$\mdline{144}, and in general, we have \mdline{144}$g_s(y)$\mdline{144} for \mdline{144}$y \in \zo^k$\mdline{144}
where \mdline{145}$k \leq n$\mdline{145} to be \mdline{145}$g_s(y) = G_{y_k}(G_{y_{k-1}}(\cdots G_{y_1}(s)))$\mdline{145}. Now we can easily
define the output of \mdline{146}$PUNCTURE$\mdline{146} as \mdline{146}$s^* = g_s(\bar{x}_1^*) \| g_s(x_1^*\bar{x}_2^*) \| \cdots  \| g_s(x_1^*x_2^* \cdots \bar{x}_{n}^*)$\mdline{146}.
Intuitively, we\mdline{147}'\mdline{147}re outputting internal nodes that will allow us to compute every value except \mdline{147}$x^*$\mdline{147}.
For example, any value that starts with \mdline{148}$\bar{x}_1$\mdline{148} can be computed using \mdline{148}$g_s(\bar{x}_1^*)$\mdline{148}. This
already means that half of the values are computable. The next step is to output a seed that allows
use to compute half of the remaining
values\mdline{151} \mdline{151}\textendash{}\mdline{151} we do this by outputting \mdline{151}$g_s(x_1^*\bar{x}_2^*)$\mdline{151}, since with this seed, we can compute
all values that begin with \mdline{152}$x_1^*\bar{x}_2^*$\mdline{152} and so on. More formally, let \mdline{152}$s^* = s_1^* \| s_2^* \| \cdots \| s_n^*$\mdline{152}
where each \mdline{153}$s_i$\mdline{153} is the \mdline{153}$n$\mdline{153}-bit string corresponding to \mdline{153}$g_s(x_1^*\cdots x_{i-1}^*\bar{x}_i^*)$\mdline{153}. Then
note that for any \mdline{154}$x \neq x^*$\mdline{154}, we must have a first-bit \mdline{154}$x_k \neq x_k^*$\mdline{154} where or all \mdline{154}$i < k$\mdline{154}, \mdline{154}$x_i = x_k^*$\mdline{154}. 
Then we should be able to use the seed \mdline{155}$s_k$\mdline{155} to compute the values of \mdline{155}$f_s(x_k)$\mdline{155} since 
\mdline{156}$s_k = g_s(x_1^*x_2^*\cdots x_{k-1}^*\bar{x}_k^*) = g_s(x_1x_2\cdots x_k{k-1}x_{k})$\mdline{156} which gives
us the \mdline{157}$k$\mdline{157}-level internal node needed for computing \mdline{157}$x$\mdline{157}.%mdk

%mdk-data-line={159}
\mdline{159}Note that in total, we output an \mdline{159}$n$\mdline{159}-bit string for each of the \mdline{159}$n$\mdline{159} bits of \mdline{159}$x^*$\mdline{159}, and therefore the 
output of punture is and \mdline{160}$n^2$\mdline{160}-string. Each of these \mdline{160}$n$\mdline{160}-bit strings can be computed efficiently,
and because we output only a polynomial number of them, we conclude that \mdline{161}$PUNCTURE$\mdline{161} is efficient.%mdk

%mdk-data-line={163}
\mdline{163}The above discussion directly lends itself to the construction of \mdline{163}$EVAL$\mdline{163}. The function \mdline{163}$EVAL$\mdline{163}, 
on input \mdline{164}$s^*$\mdline{164} and \mdline{164}$x$\mdline{164} where \mdline{164}$x \neq x^*$\mdline{164}, first calculates the least bit such that \mdline{164}$x_k \neq x_k^*$\mdline{164}.
It then searches \mdline{165}$s^*$\mdline{165} for the \mdline{165}$k$\mdline{165}-th \mdline{165}$n$\mdline{165}-bit string. Then using \mdline{165}$x_{k+1}\cdots x_{n}$\mdline{165} as a guide
along with \mdline{166}$G$\mdline{166}, it returns \mdline{166}$G_{x_n}(G_{x_{n-1}}(\cdots G_{x_{k+1}}(s_k)))$\mdline{166} as output.%mdk

%mdk-data-line={168}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={169}
\noindent\mdline{169}\textbf{Proof}.  \mdline{169}We now proof that for every \mdline{169}$x \neq x^*$\mdline{169}, \mdline{169}$EVAL(x,s^*) = f_s(x)$\mdline{169}. The proof is straight forward.
Since \mdline{170}$x \neq x^*$\mdline{170}, there exists a smallest \mdline{170}$k$\mdline{170} such that \mdline{170}$x_k \neq x_k^*$\mdline{170} where \mdline{170}$k \leq n$\mdline{170}. THen:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={173}
\begin{aligned}
EVAL(x,s^*) &= G_{x_{n}}(G_{x_{n-1}}(\cdots G_{x_{k+1}}(s_k))) \\
&= G_{x_{n}}(G_{x_{n-1}}(\cdots G_{x_{k+1}}(g_s(x_1^*x_2^*\cdots x_{k-1}^*\bar{x}_k^*))) \\
&= G_{x_{n}}(G_{x_{n-1}}(\cdots G_{x_{k+1}}(g_s(x_1x_2\cdots x_k{k-1}x_{k})))) \\
&= G_{x_{n}}(G_{x_{n-1}}(\cdots G_{x_{k+1}}(G_{x_k}(G_{x_{k-1}}(\cdots G_{x_1}(s))))) \\
&= f_s(x)
\end{aligned}
\]%mdk

%mdk-data-line={182}
\mdline{182}It is clear that in the case when \mdline{182}$x = x^*$\mdline{182}, \mdline{182}$EVAL$\mdline{182} cannot be used to calculate \mdline{182}$x^*$\mdline{182} since the 
algorithm fails to find the smallest \mdline{183}$k$\mdline{183} since \mdline{183}$x$\mdline{183} and
\mdline{184}$x^*$\mdline{184} don\mdline{184}'\mdline{184}t differ. 
We further show that even given \mdline{185}$s^*$\mdline{185}, the value \mdline{185}$f_s(x^*)$\mdline{185} is computationally indistinguishable
from the uniform distribution.%mdk

%mdk-data-line={188}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={189}
\noindent\mdline{189}\textbf{Proof}.  \mdline{189}Note that by construction, \mdline{189}$s^*$\mdline{189} reveals no information about \mdline{189}$f(x^*)$\mdline{189} since 
\mdline{190}$f(x^*) = G_{x_n}(G_{x_{n-1}}(\cdots G_{x_1}(s)))$\mdline{190}, no part of which is revealed by \mdline{190}$s^*$\mdline{190}. Therefore,
by the security of PRFs, it must be the case that \mdline{191}$f^(x^*) \approx U_n$\mdline{191}. 
On input \mdline{192}$z \in \zo^{2n}$%mdk%mdk
\end{mdbmarginx}%mdk

%mdk-data-line={195}
\mdline{195}By the construction above, we can readily see that EVAL can compute for every \mdline{195}$x \neq x^*$\mdline{195}, \mdline{195}$f_s(x)$\mdline{195}
efficiently, since it perform at most \mdline{196}$n - 1$\mdline{196} calls to \mdline{196}$G$\mdline{196}, which itself is efficient. Therefore,
we have constructed a puncturable PRF.%mdk%mdk

%mdk-data-line={199}
\item{}
%mdk-data-line={199}
\mdline{199}(30 points) Suppose that \mdline{199}$\cO$\mdline{199} is an IO obfuscator, \mdline{199}$G:\zo^n\rightarrow\zo^{3n}$\mdline{199} is a PRG and that \mdline{199}$\{ f_s \}$\mdline{199} (where \mdline{199}$f_s:\zo^{|s|}\rightarrow\zo^{|s|}$\mdline{199} is a puncturable PRF. Prove that the following is a \mdline{199}\emph{selectively secure}\mdline{199} digital signature scheme, where by this we mean a scheme that satisfies the relaxed definition where the attacker must declare the message \mdline{199}$m^*$\mdline{199} on which she will forge a signature at the beginning of the chosen-message-attack game, before seeing the public key.%mdk

%mdk-data-line={201}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={201}
\item\mdline{201}\textbf{Key generation:}\mdline{201} The signing key is \mdline{201}$s$\mdline{201} and the public key is \mdline{201}$V=\cO(V_s)$\mdline{201} where \mdline{201}$V_s(m,\sigma)$\mdline{201} outputs \mdline{201}$1$\mdline{201} if \mdline{201}$G(\sigma)=G(f_s(m))$\mdline{201} and outputs \mdline{201}$0$\mdline{201} otherwise.%mdk

%mdk-data-line={202}
\item\mdline{202}\textbf{Signature:}\mdline{202} To sign  \mdline{202}$m$\mdline{202} with key \mdline{202}$s$\mdline{202}, we output \mdline{202}$f_s(m)$\mdline{202}%mdk

%mdk-data-line={203}
\item\mdline{203}\textbf{Verification:}\mdline{203} To verify \mdline{203}$(m,\sigma)$\mdline{203} with key \mdline{203}$V$\mdline{203}, run \mdline{203}$V(m,\sigma)$\mdline{203}%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={205}
\mdline{205}As a first step, worth 15 points, for every \mdline{205}$m^*$\mdline{205}, consider the following circuit \mdline{205}$V^*_{m^*,s^*,z}$\mdline{205}: for \mdline{205}$m\neq m^*$\mdline{205} \mdline{205}$V^*_{m^*,s^*,z}(m,\sigma)$\mdline{205} outputs \mdline{205}$1$\mdline{205} iff \mdline{205}$G(EVAL(s^*,m))=G(\sigma)$\mdline{205} and for \mdline{205}$m=m^*$\mdline{205}, \mdline{205}$V^*_{m^*,s^*,z}(m,\sigma)$\mdline{205} outputs \mdline{205}$1$\mdline{205} iff \mdline{205}$G(\sigma)=z$\mdline{205}. Prove that if \mdline{205}$s^* = PUNCTURE(m^*)$\mdline{205} and \mdline{205}$z=G(f_s(m^*))$\mdline{205} then \mdline{205}$V^*_{m^*,s^*,z}$\mdline{205} computes the same function as \mdline{205}$V_s$\mdline{205}.  By padding you can assume they have the same size as well.%mdk

%mdk-data-line={207}
\mdline{207}See footnote for a hint how to complete the proof\mdline{207}\mdfootnote{4}{%mdk-data-line={244}
%mdk-data-line={244}
\noindent\mdline{244}Think of the following series of hybrids. First we can modify the key from the obfuscation of \mdline{244}$V_s$\mdline{244} to the obfuscation of \mdline{244}$V_{m^*,s^*,G(f_s(m^*))}$\mdline{244} and claim that the attackers success probability will stay the same due to the security of the IO scheme. Then we can transform the last output to \mdline{244}$G(U_n)$\mdline{244} and claim that there the success would still be the same due to the punctured PRF security. Finally we can modify the value \mdline{244}$G(U_n)$\mdline{244} to \mdline{244}$U_{3n}$\mdline{244} and claim that the suceess should still be the same due to the security of the PRG. But at this point, eith very high probability the verification algorithm \mdline{244}$V_{m^*,s^*,z}$\mdline{244} outputs \mdline{244}$0$\mdline{244} on \mdline{244}\emph{every}\mdline{244} input of the form \mdline{244}$(m^*,\sigma)$\mdline{244}.%mdk
\label{fn-hint4}%mdk%mdk
}\mdline{207}%mdk

%mdk-data-line={209}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={210}
\noindent\mdline{210}\textbf{Proof}.  \mdline{210}We proof that \mdline{210}$V_s$\mdline{210} and \mdline{210}$V_{m^*,s^*,z}^*$\mdline{210}, constructed as described above, compute the same function
if \mdline{211}$s^* = PUNCTURE(s,m^*)$\mdline{211} and \mdline{211}$z =G(f_s(m^*))$\mdline{211}. Consider the inputs \mdline{211}$m,\sigma$\mdline{211}. 
Note that under these conditions, for \mdline{212}$m \neq m^*$\mdline{212}, \mdline{212}$G(EVAL(s^*,m)) = G(f_s(m))$\mdline{212}
by the fact that \mdline{213}$\{f_s\}$\mdline{213} is puncturable. 
and therefore
\mdline{215}$V_{m^*,s^*,z}^*(m,\sigma) = 1$\mdline{215} if \mdline{215}$G(f_s(m)) = G(\sigma)$\mdline{215} and \mdline{215}$0$\mdline{215} otherwise, which is precisely
the same as \mdline{216}$V_s(m,\sigma)$\mdline{216}. Similarly, for the case where \mdline{216}$m \neq m^*$\mdline{216}, note that \mdline{216}$z = G(f_s(m^*))$\mdline{216},
and therefore \mdline{217}$V_{m^*,s^*,z}^*(m^*,\sigma) = 1$\mdline{217} if \mdline{217}$G(f_s(m^*)) = G(\sigma)$\mdline{217} and \mdline{217}$0$\mdline{217} otherwise, which is precisely the
same calculation as \mdline{218}$V_s(m^*,\sigma)$\mdline{218}.%mdk%mdk
\end{mdbmarginx}%mdk

%mdk-data-line={220}
\mdline{220}With the above, note that we can conclude that the circuits \mdline{220}$V_{m^*,s^*,z}^*$\mdline{220} and \mdline{220}$V_s$\mdline{220} compute the
same function and furthermore, with padding, are the same size. We now proceed with the proof.%mdk

%mdk-data-line={223}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={224}
\noindent\mdline{224}\textbf{Proof}.  \mdline{224}The proof follows the hint very closely, just adding a bit of formalism. The adversary selects
\mdline{225}$(m^*, \sigma^*)$\mdline{225} with no knowledge of the public key. Then note that the public key verifier,
with very high likelihood, will output \mdline{226}$0$\mdline{226} for any input \mdline{226}$(m^*,\sigma)$\mdline{226} (where we\mdline{226}'\mdline{226}re varying over
the \mdline{227}$\sigma$\mdline{227}). Therefore, the attacker will succeed with negligible probability, no matter what \mdline{227}$\sigma^*$\mdline{227}
he chooses.%mdk

%mdk-data-line={230}
\mdline{230}To see this, note that, as argued above, the circuits \mdline{230}$V_s$\mdline{230} and \mdline{230}$V_{m^*,s^*,G(f_s(m^*))}^*$\mdline{230} compute
the same function and are the same size, with padding. Therefore, by the security of the
obfuscator, the distributions \mdline{232}$\{\cO(V_s)\}$\mdline{232} and \mdline{232}$\{\cO(V_{m^*,s^*,G(f_s(m^*))}^*) \}$\mdline{232} must be indistinguishable.
Furthermore, we note that by the fact that \mdline{233}$\{f_s\}$\mdline{233} is a puncturable PRF, the distribution
\mdline{234}$f_s(m^*) \approx U_n$\mdline{234}, and therefore we have \mdline{234}$\cO(V_s) \approx \cO(V_{m^*,s^*,G(U_n)}^*)$\mdline{234}. Then,
for the final step, by the security of the PRG \mdline{235}$G$\mdline{235}, we must have that \mdline{235}$G(U_n) \approx U_{3n}$\mdline{235}, which
allows us to conclude that \mdline{236}$\cO(V_s) \approx \cO(\cO(V_{m^*,s^*,U_{3n}}^*))$\mdline{236}. At this point,
we\mdline{237}'\mdline{237}re essentially done with the proof, because if we analyze the algorithm \mdline{237}$V_{m^*,s^*,U_{3n}}^*)$\mdline{237},
we note that for any input \mdline{238}$m^*, \sigma$\mdline{238}, given that \mdline{238}$z$\mdline{238} is distributed with the uniform distribution,
the likelihood of \mdline{239}$G(\sigma) = z$\mdline{239} is negligible. Therefore any adversary will suceeed with negligible
probability, proving that our system is secure.%mdk%mdk
\end{mdbmarginx}%mdk%mdk
%mdk
\end{enumerate}%mdk%mdk

%mdk-data-line={246}
\item{}
%mdk-data-line={246}
\mdline{246}(60 points) Suppose that Bob wants Alice to compute for him a function \mdline{246}$f(x)$\mdline{246} that is polynomial time computable but still takes too much time for him to compute online (though he can invest this time in a preprocessing step, before he learns the input \mdline{246}$x$\mdline{246} he needs to compute it for). Consider the following protocols for doing so using an FHE \mdline{246}$(G,E,D,EVAL)$\mdline{246}. We will also assume \mdline{246}$EVAL$\mdline{246} is a deterministic function.%mdk%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={248}
\noindent\mdline{248}\textbf{Protocol 1:}\mdline{248}%mdk

%mdk-data-line={250}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={250}
\item\mdline{250}\textbf{Preprocessing step:}\mdline{250} Bob computes generates keys \mdline{250}$(e,d)$\mdline{250} for the FHE, and computes \mdline{250}$c_* = E_e(0^n)$\mdline{250} and \mdline{250}$c'_*= EVAL(f,c^*)$\mdline{250}. He sends \mdline{250}$e$\mdline{250} to Alice.%mdk

%mdk-data-line={251}
\item\mdline{251}\textbf{Bob's input:}\mdline{251} \mdline{251}$x\in\zo^n$\mdline{251}.%mdk

%mdk-data-line={252}
\item\mdline{252}\textbf{Bob-\textgreater{}Alice:}\mdline{252} Bob  chooses \mdline{252}$b\getsr\zo$\mdline{252}. Bob lets \mdline{252}$c_b = c_*$\mdline{252} and \mdline{252}$c_{1-b}=E_e(x)$\mdline{252} and sends \mdline{252}$c_0,c_1$\mdline{252} to Alice.%mdk

%mdk-data-line={253}
\item\mdline{253}\textbf{Bob\textless{}-Alice:}\mdline{253} Alice computes \mdline{253}$c'_0=EVAL(f,c_0)$\mdline{253}, \mdline{253}$c'_1=EVAL(f,c_1)$\mdline{253}  and sends \mdline{253}$c'_0,c'_1$\mdline{253} to Bob.%mdk

%mdk-data-line={254}
\item\mdline{254}\textbf{Bob's output:}\mdline{254} If \mdline{254}$c'_b \neq c'_*$\mdline{254} Bob rejects. Otherwise, he outputs \mdline{254}$D_d(c'_{1-b})$\mdline{254}.%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={256}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep,label=\alph*.]%mdk

%mdk-data-line={256}
\item{}
%mdk-data-line={256}
\mdline{256}(20 points) Prove that the protocol satisfies the following notion of security: for every efficient strategy \mdline{256}$A$\mdline{256} for Alice, either Bob rejects with probability at least \mdline{256}$1/3$\mdline{256} or Bob outputs the correct output with probability at least \mdline{256}$1/3$\mdline{256}.%mdk

%mdk-data-line={258}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={259}
\noindent\mdline{259}\textbf{Proof}.  \mdline{259} Suppose the above is not secure. Then there exists Alice such that Bob can be tricked. That is to say,
 there exists an efficient \mdline{260}$A$\mdline{260} such that Bob will not reject and return an incorrect output with
 probability at least \mdline{261}$1/3$\mdline{261}. Then note that we can use this adversary \mdline{261}$A$\mdline{261} to break the CPA-security
 of our encryption scheme. We construct an adversary \mdline{262}$A'$\mdline{262} which on input \mdline{262}$e$\mdline{262} will output a pair
 of messages \mdline{263}$m_0,m_1$\mdline{263} such that it can succeed with probability \mdline{263}$1/2 + p(n)$\mdline{263} where \mdline{263}$p(n)$\mdline{263} is non-negligible.
 The adversary works as follows, where the main purpose of us is to simulate Bob. 
 \mdline{265}\mdbr
\mdline{266}   1. On input \mdline{266}$e$\mdline{266} (the public key for the FHE), we output the messages \mdline{266}$m_0 = 0^n$\mdline{266} and \mdline{266}$m_1 = 1^n$\mdline{266}. 
   2. We then receive the cipher text \mdline{267}$c = E_e(m_b)$\mdline{267} for \mdline{267}$b \in_R \zo$\mdline{267}.. 
   3. We now begin the simulation of the protocol above, where we feed some arbitrary \mdline{268}$x$\mdline{268} to Bob as input.
   4. Bob then sends \mdline{269}$c_0,c_1$\mdline{269} to \mdline{269}$A$\mdline{269}. However, we intercept this message and instead send \mdline{269}$c_b = E_e(0^n)$\mdline{269}, and \mdline{269}$c_{1-b} = c$\mdline{269}.
   5. At the end of the protocol, if Bob returns an error, we pick \mdline{270}$b' \in_R \zo$\mdline{270} and return \mdline{270}$b'$\mdline{270}.
   6. Otherwise, we take Bob\mdline{271}'\mdline{271}s output and check whether it is \mdline{271}$f(m_0)$\mdline{271} or \mdline{271}$f(m_1)$\mdline{271}, and 
   once we find that it is \mdline{272}$f(m_{b'})$\mdline{272}, we return \mdline{272}$1-b'$\mdline{272}. We assume that \mdline{272}$f(m_0) = f(m_1)$\mdline{272} with negligible probability.
   \mdline{273}\mdbr
\mdline{274} Note that the above will succeed at the CPA game with probability at least \mdline{274}$1/2 + p(n)$\mdline{274} where \mdline{274}$p(n)$\mdline{274} is 
 non-negligbile. First, note that the distribution of our intercepted message is indistinguishable
 from the distribution of messages that Bob would normally send to Alice (since our randomness process is exactly
 the same as Bob\mdline{277}'\mdline{277}s internal randomness process where Bob\mdline{277}'\mdline{277}s input is \mdline{277}$x = m_b$\mdline{277}). Note that with probability
 at least \mdline{278}$1/3$\mdline{278} Bob will output an incorrect answer, and therefore by flipping the bit, our
 algorithm will always succeed in determining the correct message. With probability
 at most \mdline{280}$2/3$\mdline{280}, Bob returns an error. In this scenario, our algorithm guesses correct with \mdline{280}$1/2$\mdline{280} 
 probability. Therefore, the overall probability for success is:%mdk%mdk
\end{mdbmarginx}%mdk
\noindent\noindent\[%mdk-data-line={285}
 \Pr[A'(1^n, e) = Success] = \frac{1}{3} + \frac{2}{3}(\frac{1}{2}) = \frac{2}{3} = \frac{1}{2} + \frac{1}{6}
\]%mdk

%mdk-data-line={287}
\mdline{287}Note that we have \mdline{287}$p(n) = \frac{1}{6}$\mdline{287}, which is non-negligible. Therefore, we have \mdline{287}$A'$\mdline{287} as a successful
adversary in the CPA-game, contradicting the fact that our encryption is CPA-secure.%mdk

%mdk-data-line={290}
\mdline{290}b. (20 points) Suppose that we run Protocol 1 \mdline{290}\emph{twice}\mdline{290} for two inputs \mdline{290}$x_1,x_2$\mdline{290} with the same preprocessing step. The notion of security is now that for every efficient strategy \mdline{290}$A$\mdline{290} for Alice, either Bob rejects with probability at least \mdline{290}$1/3$\mdline{290} or Bob outputs the correct outputs for both \mdline{290}$x_1$\mdline{290} and \mdline{290}$x_2$\mdline{290} (i.e., \mdline{290}$f(x_1)$\mdline{290} and \mdline{290}$f(x_2)$\mdline{290}) with probability at least \mdline{290}$1/3$\mdline{290}. Prove that this protocol satisfies this notion of security or give a counterexample (a strategy for Alice that would violate this property).%mdk

%mdk-data-line={292}
\mdline{292}We first clarify the statement in the problem. We assume that what is asked is whether the
protocol is secure if Bob runs the
pre-processing step \mdline{294}\emph{once}\mdline{294} and then uses its results to interact \mdline{294}\emph{twice}\mdline{294} with Alice (following the protocol).%mdk

%mdk-data-line={296}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={297}
\noindent\mdline{297}\textbf{Proof}.  \mdline{297}We show that this setting is not secure. Let \mdline{297}$A$\mdline{297} be our adversary. Then note that \mdline{297}$A$\mdline{297} simply does
the following. On receiving \mdline{298}$c_0^1,c_1^1$\mdline{298} (the first function inputs from Bob), \mdline{298}$A$\mdline{298} performs
the same calculations as Alice, but additionally stores the results \mdline{299}$c_0^1,c_1^1$\mdline{299} locally. Note that
with probability \mdline{300}$1$\mdline{300}, Bob correctly computes \mdline{300}$f(x_1)$\mdline{300}. On receiving
the second inputs from Bob, \mdline{301}$c_0^2,c_1^2$\mdline{301}, our adversary now compares them to the stored \mdline{301}$c_0^1,c_1^1$\mdline{301}.
Note that since Bob re-used his pre-processing step for this second set of messages, the encryption
for \mdline{303}$c* =E_e(0)$\mdline{303} will be found in both sets. Let \mdline{303}$c_s^1 = c_{s'}^2$\mdline{303} for some \mdline{303}$s,s' \in zo$\mdline{303} (these
are the two encryptions that match (at least two of which must exist, if more, just take any two
satisfying assignments)). Note that with probability \mdline{305}$1- negl$\mdline{305}, we have that \mdline{305}$c_s^1 = c_{s'}^2 = c^* = E_e(0^n)$\mdline{305}
since it is unlikely for either \mdline{306}$x_1 = 0^n, x^2 = 0^n$\mdline{306}, or \mdline{306}$x_1 = x_1$\mdline{306} (this occurs with negligible probability).
Then by the above process, we have determined Bob\mdline{307}'\mdline{307}s internal randomness in the second round 
since it must be the case that \mdline{308}$b^2 = s'$\mdline{308} (as well as the first round, since \mdline{308}$b^1 = s$\mdline{308}). With this
in hand, \mdline{309}$A$\mdline{309} replies with the encryptions \mdline{309}$c_{b^2}' = EVAL(f,c_{s'}^2)$\mdline{309} and \mdline{309}$c_{1-b^2}' = EVAL(f,c_{1-s}^1)$\mdline{309}.
Note that \mdline{310}$c_{b^2}' = EVAL(f,c_{s'}^2) = EVAL(f,c_{s}^1) = EVAL(f,c_*) = c'_*$\mdline{310}, since \mdline{310}$EVAL$\mdline{310} is 
deterministic, and therefore Bob does not reject our input. However, Bob will output
\mdline{312}$D_d(c'_{1-b^2}) = D_d(EVAL(f,c_{1-s}^1)) = D_d(E_e(f(x_1))) = f(x_1)$\mdline{312}. Note that 
if we assume that \mdline{313}$f(x_1) = f(x_2)$\mdline{313} with \mdline{313}$negl$\mdline{313} probability, then we have an adversary \mdline{313}$A$\mdline{313} 
under which Bob will always output the results \mdline{314}$f(x_1),f(x_1)$\mdline{314}. Therefore, Bob rejects with
probability \mdline{315}$0 \leq 1/3$\mdline{315} or accepts and outputs the correct outputs with probability \mdline{315}$0 \leq 1/3$\mdline{315}. 
Furthermore, note that \mdline{316}$A$\mdline{316} is efficient since it behaves exactly as Alice would except for storing
some additional information. We therefore conclude that the protocol is not secure, by our 
given definition of security.%mdk%mdk
\end{mdbmarginx}%mdk

%mdk-data-line={320}
\mdline{320}c. (20 points) Consider the following protocol:%mdk

%mdk-data-line={322}
\mdline{322}\textbf{Protocol 2:}\mdline{322}%mdk

%mdk-data-line={324}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={324}
\item\mdline{324}\textbf{Preprocessing step:}\mdline{324} Bob computes generates two independent pairs of keys \mdline{324}$(e,d)$\mdline{324} \mdline{324}$(e',d')$\mdline{324} for the FHE, and computes \mdline{324}$c_* = E_e(0^n)$\mdline{324} and \mdline{324}$c'_*= EVAL(f,c^*)$\mdline{324}. He sends \mdline{324}$e,e'$\mdline{324} to Alice.%mdk

%mdk-data-line={325}
\item\mdline{325}\textbf{Bob's input:}\mdline{325} \mdline{325}$x\in\zo^n$\mdline{325}.%mdk

%mdk-data-line={326}
\item\mdline{326}\textbf{Bob-\textgreater{}Alice:}\mdline{326} Bob  chooses \mdline{326}$b\getsr\zo$\mdline{326}. Bob lets \mdline{326}$c_b = c_*$\mdline{326} and \mdline{326}$c_{1-b}=E_e(x)$\mdline{326} and sends \mdline{326}$c'_0= E_{e'}(c_0),c'_1= E_{e'}(c_1)$\mdline{326} to Alice.%mdk

%mdk-data-line={327}
\item\mdline{327}\textbf{Bob\textless{}-Alice:}\mdline{327} Alice defines the function \mdline{327}$g(c)=EVAL(f,c)$\mdline{327}  computes \mdline{327}$c''_0=EVAL(g,c'_0)$\mdline{327}, \mdline{327}$c''_1=EVAL(g,c'_1)$\mdline{327}  and sends \mdline{327}$c''_0,'c'_1$\mdline{327} to Bob.%mdk

%mdk-data-line={328}
\item\mdline{328}\textbf{Bob's output:}\mdline{328} If \mdline{328}$D_{d'}(c''_b) \neq c'_*$\mdline{328} Bob rejects. Otherwise, he outputs \mdline{328}$D_{d'}(D_d(c''_{1-b}))$\mdline{328}.%mdk
%mdk
\end{itemize}%mdk
\mdline{330}Prove that for every polynomial \mdline{330}$k$\mdline{330} and \mdline{330}$x_1,\ldots,x_k$\mdline{330}, Protocol 2 satisfies the property that if we run the processing step once and then run the protocol \mdline{330}$k$\mdline{330} times with inputs  \mdline{330}$x_1,\ldots,x_k$\mdline{330} then for every efficient strategy of Alice, either Bob rejects with probability at least \mdline{330}$1/3$\mdline{330}, or he outputs all the correct \mdline{330}$k$\mdline{330} outputs with probability at least \mdline{330}$1/3$\mdline{330}.

%mdk-data-line={331}
\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
%mdk-data-line={332}
\noindent\mdline{332}\textbf{Proof}.  \mdline{332}We show that the protocol above is secure for \mdline{332}$k$\mdline{332} rounds by showing that its insecurity implies the 
insecurity of the single round protocol from part \mdline{333}$(a)$\mdline{333}. Suppose that the protocol, as described,
is not secure. Then there exists an efficient adversary \mdline{334}$A$\mdline{334} that can trick Bob into rejecting 
with probability \mdline{335}$<1/3$\mdline{335} and outputting the correct results with probability \mdline{335}$<1/3$\mdline{335}. If this is the case, then note 
that there must exists some round \mdline{336}$f$\mdline{336} at which \mdline{336}$Bob$\mdline{336} does not reject and yet outputs the correct 
computation with low probability. Let \mdline{337}$y_i$\mdline{337} be the output of \mdline{337}$Bob$\mdline{337} in the \mdline{337}$i$\mdline{337}-th round. 
Then we must have
that there exists a \mdline{339}$f$\mdline{339} such that \mdline{339}$y_f \neq f(x_f)$\mdline{339} with probability \mdline{339}$> 2/3$\mdline{339} and for all \mdline{339}$i \in [1,k]$\mdline{339}, 
Bob did not abort with probability \mdline{340}$> 2/3$\mdline{340}. Then consider this single round \mdline{340}$f$\mdline{340} where the failure occurred.%mdk

%mdk-data-line={342}
\mdline{342}Now consider the protocol from part (a) modified so that it does the following: the input
fed to Bob is \mdline{343}$x^a = E_e(x_k)$\mdline{343}. Then in the protocol from (a), Bob will send \mdline{343}$c_b^a = c^* = E_{e'}(E_e(0^n))$\mdline{343}
and \mdline{344}$c_{1-b}^a = E_{e'}(x) = E_{e'}(E_e(x_k))$\mdline{344}, which have a distribution that is indistinguishable
from the outputs Bob would have
sent in the \mdline{346}$k$\mdline{346}-th round in this new protocol (from part c).\mdline{346}\mdbr
\mdline{347}Note that in the protocol from (a), Bob receives from \mdline{347}$A$\mdline{347}
the values \mdline{348}$c_0' = EVAL(g,c_0)$\mdline{348} and \mdline{348}$c_1' = EVAL(g,c_1)$\mdline{348}, which are precisely the values that the
adversary \mdline{349}$A$\mdline{349} must fake. Therefore, we simply forward the values made by \mdline{349}$A$\mdline{349} in the protocol from
(c) in round \mdline{350}$k$\mdline{350} to Bob in the protocol from \mdline{350}$(a)$\mdline{350}. Then note by assumption, we must necessarily have that
with high probability, \mdline{351}$D_{d'}(c''_b) = c_*'$\mdline{351} which implies that with high probability we have
\mdline{352}$g(c_b) = c_*'$\mdline{352}. Then note that \mdline{352}$g(c_b)= EVAL(f,c_b) = EVAL(f,c_b) = EVAL(f,c_*) = EVAL(f, E_e(0^n)) = EVAL(f, c_*^a)$\mdline{352} where
\mdline{353}$c_*^a$\mdline{353} is as defined in the modified protocol from (a), so with high probability,
Bob accepts the input as valid since \mdline{354}$c'_b = c'_*$\mdline{354}. By a similar line of reasoning, Bob from protocol 
\mdline{355}$(a)$\mdline{355} will then proceed to compute \mdline{355}$D_{d'}(c'_{1-b})$\mdline{355} which is the same as we would have computed 
in the \mdline{356}$k$\mdline{356}-th round. Therefore, we conclude that the two protocols are equivalent, and therefore
the insecurity of protocol c implies the insecurity of protocol a, a contradiction.%mdk%mdk
\end{mdbmarginx}%mdk%mdk
%mdk
\end{enumerate}%mdk%mdk


\end{document}
